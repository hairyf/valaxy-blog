import{_ as p}from"./ValaxyMain.vue_vue_type_script_setup_true_lang-_PHymMwZ.js";import{b as m,e as b,w as n,f,a as k,p as o,g as l,h as t,i as v,r as s}from"./app-C5E7XBok.js";const C={__name:"branch",setup(h,{expose:g}){const a=JSON.parse('{"title":"Git 分支控制","description":"","frontmatter":{"title":"Git 分支控制","date":"2019-10-07 15:00:00","categories":["Notes","Git"],"tags":["Git"]},"headers":[{"level":2,"title":"创建&切换分支","slug":"创建-切换分支","link":"#创建-切换分支","children":[{"level":3,"title":"创建分支","slug":"创建分支","link":"#创建分支","children":[]},{"level":3,"title":"新建且使分支指向提交对象","slug":"新建且使分支指向提交对象","link":"#新建且使分支指向提交对象","children":[]},{"level":3,"title":"切换分支","slug":"切换分支","link":"#切换分支","children":[]},{"level":3,"title":"新建分支并切换分支","slug":"新建分支并切换分支","link":"#新建分支并切换分支","children":[]}]},{"level":2,"title":"查看分支","slug":"查看分支","link":"#查看分支","children":[{"level":3,"title":"查看每个分支最后一次提交","slug":"查看每个分支最后一次提交","link":"#查看每个分支最后一次提交","children":[]},{"level":3,"title":"查看哪些分支已经合并到当前分支","slug":"查看哪些分支已经合并到当前分支","link":"#查看哪些分支已经合并到当前分支","children":[]},{"level":3,"title":"查看所有包含未合并工作的分支","slug":"查看所有包含未合并工作的分支","link":"#查看所有包含未合并工作的分支","children":[]},{"level":3,"title":"查看项目分叉历史","slug":"查看项目分叉历史","link":"#查看项目分叉历史","children":[]}]},{"level":2,"title":"删除分支","slug":"删除分支","link":"#删除分支","children":[]},{"level":2,"title":"分支合并","slug":"分支合并","link":"#分支合并","children":[{"level":3,"title":"快进fast-forward","slug":"快进fast-forward","link":"#快进fast-forward","children":[]},{"level":3,"title":"产生文件冲突","slug":"产生文件冲突","link":"#产生文件冲突","children":[]}]},{"level":2,"title":"分支流程","slug":"分支流程","link":"#分支流程","children":[{"level":3,"title":"创建分支","slug":"创建分支-1","link":"#创建分支-1","children":[]},{"level":3,"title":"修改分支并提交","slug":"修改分支并提交","link":"#修改分支并提交","children":[]},{"level":3,"title":"切回主分支","slug":"切回主分支","link":"#切回主分支","children":[]}]},{"level":2,"title":"分支实际案例","slug":"分支实际案例","link":"#分支实际案例","children":[{"level":3,"title":"工作流","slug":"工作流","link":"#工作流","children":[]},{"level":3,"title":"紧急任务","slug":"紧急任务","link":"#紧急任务","children":[]},{"level":3,"title":"详细流程","slug":"详细流程","link":"#详细流程","children":[]}]},{"level":2,"title":"长期分支","slug":"长期分支","link":"#长期分支","children":[]},{"level":2,"title":"特性分支","slug":"特性分支","link":"#特性分支","children":[]},{"level":2,"title":"分支本质","slug":"分支本质","link":"#分支本质","children":[]},{"level":2,"title":"分支原理","slug":"分支原理","link":"#分支原理","children":[{"level":3,"title":".git/refs 目录","slug":"git-refs-目录","link":"#git-refs-目录","children":[]},{"level":3,"title":"HEAD 引用","slug":"head-引用","link":"#head-引用","children":[]}]}],"relativePath":"pages/posts/notes/git/branch.md","path":"/home/runner/work/valaxy-blog/valaxy-blog/pages/posts/notes/git/branch.md","lastUpdated":1725453888000}'),d=k(),r=a.frontmatter||{};return d.meta.frontmatter=Object.assign(d.meta.frontmatter||{},a.frontmatter||{}),o("pageData",a),o("valaxy:frontmatter",r),globalThis.$frontmatter=r,g({frontmatter:{title:"Git 分支控制",date:"2019-10-07 15:00:00",categories:["Notes","Git"],tags:["Git"]}}),(e,i)=>{const u=p;return m(),b(u,{frontmatter:f(r)},{"main-content-md":n(()=>[i[0]||(i[0]=l("p",null,"几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。",-1)),i[1]||(i[1]=l("p",null,"对于大项目来说，这样的过程会耗费很多时间。",-1)),i[2]||(i[2]=l("p",null,[t("而 "),l("strong",null,"Git 的分支模型极其的高效轻量的。是 Git 的必杀技特性"),t("，也正因为这一特性，使 得 Git 从众多版本控制系统中脱颖而出，为你创建了一个可以移动的新的指针。")],-1)),v(" more "),i[3]||(i[3]=l("p",null,"比如，创建一个 testing 分 支：git branch testing。这会在当前所在的提交对象上创建一个指针",-1)),i[4]||(i[4]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece93e8c61dc3b8ebb912d.jpg",alt:"创建分支",loading:"lazy",decoding:"async"})],-1)),i[5]||(i[5]=l("h2",{id:"创建-切换分支",tabindex:"-1"},[t("创建&切换分支 "),l("a",{class:"header-anchor",href:"#创建-切换分支","aria-label":'Permalink to "创建&切换分支"'},"​")],-1)),i[6]||(i[6]=l("h3",{id:"创建分支",tabindex:"-1"},[t("创建分支 "),l("a",{class:"header-anchor",href:"#创建分支","aria-label":'Permalink to "创建分支"'},"​")],-1)),i[7]||(i[7]=l("p",null,[l("code",null,"git branch 分支名"),t(" 分支名 创建 一个新分支，并不会自动切换到新分支中去")],-1)),i[8]||(i[8]=l("h3",{id:"新建且使分支指向提交对象",tabindex:"-1"},[t("新建且使分支指向提交对象 "),l("a",{class:"header-anchor",href:"#新建且使分支指向提交对象","aria-label":'Permalink to "新建且使分支指向提交对象"'},"​")],-1)),i[9]||(i[9]=l("p",null,[l("code",null,"git branch 分支名 提交对象hash")],-1)),i[10]||(i[10]=l("h3",{id:"切换分支",tabindex:"-1"},[t("切换分支 "),l("a",{class:"header-anchor",href:"#切换分支","aria-label":'Permalink to "切换分支"'},"​")],-1)),i[11]||(i[11]=l("p",null,[l("code",null,"git checkout 分支名"),t(" 切回主分支："),l("code",null,"git checkout master")],-1)),i[12]||(i[12]=l("p",null,[l("strong",null,"分支切换会改变你工作目录中的文件"),t("，在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换 到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如 果 Git 不能干净利落地完成这个任务，它将禁止切换分支")],-1)),i[13]||(i[13]=l("p",null,[l("strong",null,"切换分支会动三个地方"),t("：HEAD、暂存区、工作目录")],-1)),i[14]||(i[14]=l("p",null,[l("strong",null,"注意要点"),t("：每次切换分支前 当前分支一定得是干净的(已提交状态)，以及在切换分支时 如果当前分支上有未暂存的修改(第一次) 或者 有未提交的暂存(第一次)分支可以切换成功 但是这种操作可能会污染其他分支")],-1)),i[15]||(i[15]=l("h3",{id:"新建分支并切换分支",tabindex:"-1"},[t("新建分支并切换分支 "),l("a",{class:"header-anchor",href:"#新建分支并切换分支","aria-label":'Permalink to "新建分支并切换分支"'},"​")],-1)),i[16]||(i[16]=l("p",null,[l("code",null,"git checkout -b 分支名")],-1)),i[17]||(i[17]=l("h2",{id:"查看分支",tabindex:"-1"},[t("查看分支 "),l("a",{class:"header-anchor",href:"#查看分支","aria-label":'Permalink to "查看分支"'},"​")],-1)),i[18]||(i[18]=l("p",null,[l("code",null,"git branch"),t(" 不只是可以创建与删除分支。 如果不加任何参数运行它， 会得到当前所有分支的一个列表")],-1)),i[19]||(i[19]=l("h3",{id:"查看每个分支最后一次提交",tabindex:"-1"},[t("查看每个分支最后一次提交 "),l("a",{class:"header-anchor",href:"#查看每个分支最后一次提交","aria-label":'Permalink to "查看每个分支最后一次提交"'},"​")],-1)),i[20]||(i[20]=l("p",null,[l("code",null,"git branch -v")],-1)),i[21]||(i[21]=l("h3",{id:"查看哪些分支已经合并到当前分支",tabindex:"-1"},[t("查看哪些分支已经合并到当前分支 "),l("a",{class:"header-anchor",href:"#查看哪些分支已经合并到当前分支","aria-label":'Permalink to "查看哪些分支已经合并到当前分支"'},"​")],-1)),i[22]||(i[22]=l("p",null,"git branch –merged 查看哪些分支已经合并到当前分支，在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；",-1)),i[23]||(i[23]=l("h3",{id:"查看所有包含未合并工作的分支",tabindex:"-1"},[t("查看所有包含未合并工作的分支 "),l("a",{class:"header-anchor",href:"#查看所有包含未合并工作的分支","aria-label":'Permalink to "查看所有包含未合并工作的分支"'},"​")],-1)),i[24]||(i[24]=l("p",null,"git branch --no-merged 查看所有包含未合并工作的分支 尝试使用 git branch -d 命令删除在这个列表中的分支时会失败。 如果真的想要删除分支并丢掉那些工作，可以使用 -D 选项强制删 除它。",-1)),i[25]||(i[25]=l("h3",{id:"查看项目分叉历史",tabindex:"-1"},[t("查看项目分叉历史 "),l("a",{class:"header-anchor",href:"#查看项目分叉历史","aria-label":'Permalink to "查看项目分叉历史"'},"​")],-1)),i[26]||(i[26]=l("p",null,[l("code",null,"git log --oneline --decorate --graph --all")],-1)),i[27]||(i[27]=l("h2",{id:"删除分支",tabindex:"-1"},[t("删除分支 "),l("a",{class:"header-anchor",href:"#删除分支","aria-label":'Permalink to "删除分支"'},"​")],-1)),i[28]||(i[28]=l("p",null,[l("code",null,"git branch -d 分支名")],-1)),i[29]||(i[29]=l("h2",{id:"分支合并",tabindex:"-1"},[t("分支合并 "),l("a",{class:"header-anchor",href:"#分支合并","aria-label":'Permalink to "分支合并"'},"​")],-1)),i[30]||(i[30]=l("p",null,[l("code",null,"git merge 分支名")],-1)),i[31]||(i[31]=l("h3",{id:"快进fast-forward",tabindex:"-1"},[t("快进"),l("code",null,"fast-forward"),t(),l("a",{class:"header-anchor",href:"#快进fast-forward","aria-label":'Permalink to "快进`fast-forward`"'},"​")],-1)),i[32]||(i[32]=l("p",null,[t('在合并的时候，有时候会出现"快进（'),l("code",null,"fast-forward"),t('）"这个词。 由于当 前 master 分支所指向的提交是你当前提交的直接上游，所以 Git 只是简 单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个 分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的 将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分 歧——这就叫做 “快进（'),l("code",null,"fast-forward"),t("）")],-1)),i[33]||(i[33]=l("h3",{id:"产生文件冲突",tabindex:"-1"},[t("产生文件冲突 "),l("a",{class:"header-anchor",href:"#产生文件冲突","aria-label":'Permalink to "产生文件冲突"'},"​")],-1)),i[34]||(i[34]=l("p",null,"有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个 文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你 对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一 处，在合并它们的时候就会产生合并冲突",-1)),i[35]||(i[35]=l("p",null,[t("此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂 停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻 使用 "),l("code",null,"git status"),t(" 命令来查看那些因包含合并冲突而处于未合并（unmerged） 状态的文件")],-1)),i[36]||(i[36]=l("p",null,"任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。",-1)),i[37]||(i[37]=l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes material-theme-darker material-theme-lighter vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,'<div id="footer">')]),t(`
`),l("span",{class:"line"},[l("span",null,"please contact us at support@github.com")]),t(`
`),l("span",{class:"line"},[l("span",null,"</div>")])])]),l("button",{class:"collapse"})],-1)),i[38]||(i[38]=l("p",null,"在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其 标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记 为冲突已解决",-1)),i[39]||(i[39]=l("h2",{id:"分支流程",tabindex:"-1"},[t("分支流程 "),l("a",{class:"header-anchor",href:"#分支流程","aria-label":'Permalink to "分支流程"'},"​")],-1)),i[40]||(i[40]=l("h3",{id:"创建分支-1",tabindex:"-1"},[t("创建分支 "),l("a",{class:"header-anchor",href:"#创建分支-1","aria-label":'Permalink to "创建分支"'},"​")],-1)),i[41]||(i[41]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece93e8c61dc3b8ebb912d.jpg",alt:"",loading:"lazy",decoding:"async"})],-1)),i[42]||(i[42]=l("h3",{id:"修改分支并提交",tabindex:"-1"},[t("修改分支并提交 "),l("a",{class:"header-anchor",href:"#修改分支并提交","aria-label":'Permalink to "修改分支并提交"'},"​")],-1)),i[43]||(i[43]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62fb4d7416f2c2beb1ed2003.jpg",alt:"",loading:"lazy",decoding:"async"})],-1)),i[44]||(i[44]=l("h3",{id:"切回主分支",tabindex:"-1"},[t("切回主分支 "),l("a",{class:"header-anchor",href:"#切回主分支","aria-label":'Permalink to "切回主分支"'},"​")],-1)),i[45]||(i[45]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece99b8c61dc3b8ebcd413.jpg",alt:"切回分支",loading:"lazy",decoding:"async"})],-1)),i[46]||(i[46]=l("h2",{id:"分支实际案例",tabindex:"-1"},[t("分支实际案例 "),l("a",{class:"header-anchor",href:"#分支实际案例","aria-label":'Permalink to "分支实际案例"'},"​")],-1)),i[47]||(i[47]=l("h3",{id:"工作流",tabindex:"-1"},[t("工作流 "),l("a",{class:"header-anchor",href:"#工作流","aria-label":'Permalink to "工作流"'},"​")],-1)),i[48]||(i[48]=l("ol",null,[l("li",null,"开发某个网站。"),l("li",null,"为实现某个新的需求，创建一个分支。"),l("li",null,"在这个分支上开展工作。")],-1)),i[49]||(i[49]=l("h3",{id:"紧急任务",tabindex:"-1"},[t("紧急任务 "),l("a",{class:"header-anchor",href:"#紧急任务","aria-label":'Permalink to "紧急任务"'},"​")],-1)),i[50]||(i[50]=l("p",null,"正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你 将按照如下方式来处理：",-1)),i[51]||(i[51]=l("ol",null,[l("li",null,"切换到你的线上分支（production branch）。"),l("li",null,"为这个紧急任务新建一个分支，并在其中修复它。"),l("li",null,"在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改 动推送到线上分支。"),l("li",null,"切换回你最初工作的分支上，继续工作。")],-1)),i[52]||(i[52]=l("h3",{id:"详细流程",tabindex:"-1"},[t("详细流程 "),l("a",{class:"header-anchor",href:"#详细流程","aria-label":'Permalink to "详细流程"'},"​")],-1)),i[53]||(i[53]=l("p",null,"首先，我们假设你正在你的项目上工作，并且已经有一些提交",-1)),i[54]||(i[54]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9b58c61dc3b8ebd3e74.jpg",alt:"正常工作",loading:"lazy",decoding:"async"})],-1)),i[55]||(i[55]=l("p",null,"现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要 新建一个分支并同时切换到那个分支上",-1)),i[56]||(i[56]=l("p",null,"你可以运行一个带有 -b 参数的 git checkout 命令",-1)),i[57]||(i[57]=l("div",{class:"language-sh vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"sh"),l("pre",{class:"shiki shiki-themes material-theme-darker material-theme-lighter vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-dark":"#FFCB6B","--shiki-light":"#E2931D"}},"git"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," checkout"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," -b"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," iss53"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," ="),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," git"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," branch"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," iss53"),l("span",{style:{"--shiki-dark":"#89DDFF","--shiki-light":"#39ADB5"}}," &&"),l("span",{style:{"--shiki-dark":"#FFCB6B","--shiki-light":"#E2931D"}}," git"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," checkout"),l("span",{style:{"--shiki-dark":"#C3E88D","--shiki-light":"#91B859"}}," iss53")])])]),l("button",{class:"collapse"})],-1)),i[58]||(i[58]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9c18c61dc3b8ebd6b34.jpg",alt:"创建分支解决问题",loading:"lazy",decoding:"async"})],-1)),i[59]||(i[59]=l("p",null,"你继续在 #53 问题上工作，并且做了一些提交。",-1)),i[60]||(i[60]=l("p",null,"在此过程中，iss53 分 支在不断的向前推进，因为你已经检出到该分支",-1)),i[61]||(i[61]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9d58c61dc3b8ebdc069.png",alt:"分支提交",loading:"lazy",decoding:"async"})],-1)),i[62]||(i[62]=l("p",null,[l("strong",null,"！！！现在你接到那个电话，有个紧急问题等待你来解决")],-1)),i[63]||(i[63]=l("p",null,[t("有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一 起，你也不需要花大力气来还原关于 53## 问题的修改，然后再添加关于这个 紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换 回 master 分支 但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有 被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到 该分支。 最好的方法是，"),l("strong",null,"在你切换分支之前，保持好一个干净的状态。"),l("code",null,"git checkout master"),t("（提 交你的所有修改）")],-1)),i[64]||(i[64]=l("p",null,[t("这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可 以专心修复紧急问题了。 请牢记：当你"),l("strong",null,"切换分支的时候，Git 会重置你的工 作目录"),t("，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会 自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交 时的样子一模一样。")],-1)),i[65]||(i[65]=l("p",null,[t("！！！接下来，你要修复这个紧急问题。 让我们"),l("strong",null,"建立一个针对该紧急问 题的分支（hotfix branch）"),t("，在该分支上工作直到问题解决")],-1)),i[66]||(i[66]=l("p",null,[l("code",null,"git checkout -b hotfix"),l("strong",null,"问题解决后"),t("："),l("code",null,"git commit -a -m 'fixed the broken email address'")],-1)),i[67]||(i[67]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9e28c61dc3b8ebe01d8.jpg",alt:"问题解决提交",loading:"lazy",decoding:"async"})],-1)),i[68]||(i[68]=l("p",null,[t("！！！你可以运行你的测试，确保你的修改是正确的，"),l("strong",null,"然后将其合并回你 的 master 分支来部署到线上。"),t(" 你可以使用 "),l("code",null,"git merge"),t(" 命令来达到上述目的")],-1)),i[69]||(i[69]=l("p",null,[l("code",null,"git checkout master"),t(),l("code",null,"git merge hotfix")],-1)),i[70]||(i[70]=l("p",null,[t('在合并的时候，有时候会出现"快进（'),l("code",null,"fast-forward"),t('）"这个词。 由于当 前 master 分支所指向的提交是你当前提交的直接上游，所以 Git 只是简 单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个 分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的 将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分 歧——这就叫做 “快进（'),l("code",null,"fast-forward"),t("）")],-1)),i[71]||(i[71]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9ec8c61dc3b8ebe22d4.jpg",alt:"问题解决合并分支",loading:"lazy",decoding:"async"})],-1)),i[72]||(i[72]=l("p",null,[t("！！！关于这个紧急问题的解决方案发布之后，"),l("strong",null,"你准备回到被打断之前时 的工作中"),t("。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支。现在你可以切换回你正在工作的分支继续你的工 作，也就是针对 #53 问题的那个分支")],-1)),i[73]||(i[73]=l("p",null,[l("code",null,"git branch -d hotfix"),t(),l("code",null,"git checkout iss53")],-1)),i[74]||(i[74]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ece9f88c61dc3b8ebe51fb.jpg",alt:"回到分支",loading:"lazy",decoding:"async"})],-1)),i[75]||(i[75]=l("p",null,[t("你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需 要拉取 hotfix 所做的修改，你可以使用 git merge master 命令 "),l("strong",null,"将 master 分支合并入 iss53 分支"),t("，或者你也可以等到 iss53 分支完成其 使命，再将其合并回 master 分支。 "),l("code",null,"git checkout master"),t(),l("code",null,"git merge iss53")],-1)),i[76]||(i[76]=l("p",null,"当前的合并和你之前合并 hotfix 分支的时候看起来有一点不一样。 在 这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因 为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不 得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端 所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单 的三方合并。",-1)),i[77]||(i[77]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea028c61dc3b8ebe7289.jpg",alt:"子分支合并主分支",loading:"lazy",decoding:"async"})],-1)),i[78]||(i[78]=l("p",null,"和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的 快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在 于他有不止一个父提交。",-1)),i[79]||(i[79]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea318c61dc3b8ebf3034.jpg",alt:"子分支合并主分支2",loading:"lazy",decoding:"async"})],-1)),i[80]||(i[80]=l("p",null,"需要指出的是，Git 会自行决定选取哪一个提交作为最优的 共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系 统或者 Subversion （1.5 版本之前）不同，在这些古老的版本 管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个 优势使其在合并操作上比其他系统要简单很多",-1)),i[81]||(i[81]=l("p",null,[l("strong",null,"最终删除 iss53 号分支"),t("：git branch -d iss53")],-1)),i[82]||(i[82]=l("p",null,[l("strong",null,"冲突"),t("：有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个 文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你 对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一 处，在合并它们的时候就会产生合并冲突")],-1)),i[83]||(i[83]=l("p",null,[t("此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂 停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻 使用 "),l("code",null,"git status"),t(" 命令来查看那些因包含合并冲突而处于未合并（unmerged） 状态的文件")],-1)),i[84]||(i[84]=l("p",null,"任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。",-1)),i[85]||(i[85]=l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes material-theme-darker material-theme-lighter vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,'<div id="footer">')]),t(`
`),l("span",{class:"line"},[l("span",null,"please contact us at support@github.com")]),t(`
`),l("span",{class:"line"},[l("span",null,"</div>")])])]),l("button",{class:"collapse"})],-1)),i[86]||(i[86]=l("p",null,"在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其 标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记 为冲突已解决",-1)),i[87]||(i[87]=l("h2",{id:"长期分支",tabindex:"-1"},[t("长期分支 "),l("a",{class:"header-anchor",href:"#长期分支","aria-label":'Permalink to "长期分支"'},"​")],-1)),i[88]||(i[88]=l("p",null,"许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完 全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名 为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支 不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。， 等待下一次的发布。",-1)),i[89]||(i[89]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea488c61dc3b8ebf88ff.jpg",alt:"公司常见模式",loading:"lazy",decoding:"async"})],-1)),i[90]||(i[90]=l("p",null,"随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截， 而前沿分支的指针往往比较靠前。",-1)),i[91]||(i[91]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea538c61dc3b8ebfb497.jpg",alt:"分支右移",loading:"lazy",decoding:"async"})],-1)),i[92]||(i[92]=l("h2",{id:"特性分支",tabindex:"-1"},[t("特性分支 "),l("a",{class:"header-anchor",href:"#特性分支","aria-label":'Permalink to "特性分支"'},"​")],-1)),i[93]||(i[93]=l("p",null,"特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来 实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS） 上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而， 在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。",-1)),i[94]||(i[94]=l("p",null,[l("strong",null,"实例"),t("： 考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解 决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C2，这时思路 断了，你暂时放弃修复 iss91，切回主分支又工作到了 c3（画了几个页面）。 这时你突然对 iss91 问题有了新的想法，你切回 iss91 继续工作到了 c6。 在完成了对 iss91 的 bug 修复之后。你发现你 C4 之后的修改都没有使用 ES6 语法。于是你再新建一个 iss91v2 分支重新使用 ES6 语法开发到 C8，写 了一会写累了。接着你回到 master 分支又画了一会页面到 C10，画完页面 后你一咬牙切回 iss91v2 完成 es6 版本的修改到 C11. 你又冒出了一个不 太确定的想法，切回 master 后新建一个 dumbidea 分支，并在上面做些实 验。 你的提交历史看起来像下面这个样子：")],-1)),i[95]||(i[95]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea5e8c61dc3b8ebfe4fa.jpg",alt:"提交历史",loading:"lazy",decoding:"async"})],-1)),i[96]||(i[96]=l("p",null,"现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使 用在 iss91v2 分支中方案；另外，你将 dumbidea 分支拿给你的同事看 过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢 弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交 历史看起来像下面这个样子：",-1)),i[97]||(i[97]=l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes material-theme-darker material-theme-lighter vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,"在 master 分支是先合并 dumbidea 分支")]),t(`
`),l("span",{class:"line"},[l("span",null,"切回 iss91v2 分支合并掉 iss91")]),t(`
`),l("span",{class:"line"},[l("span",null,"删除 iss91")]),t(`
`),l("span",{class:"line"},[l("span",null,"切回 master 分支再合并 iss91v2 分支")])])]),l("button",{class:"collapse"})],-1)),i[98]||(i[98]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea5e8c61dc3b8ebfe4fa.jpg",alt:"提交历史2",loading:"lazy",decoding:"async"})],-1)),i[99]||(i[99]=l("h2",{id:"分支本质",tabindex:"-1"},[t("分支本质 "),l("a",{class:"header-anchor",href:"#分支本质","aria-label":'Permalink to "分支本质"'},"​")],-1)),i[100]||(i[100]=l("p",null,"Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支 名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对 象的 master 分支。 它会在每次的提交操作中自动向前移动。",-1)),i[101]||(i[101]=l("p",null,"**注意 **：Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所 以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数 人都懒得去改动它。",-1)),i[102]||(i[102]=l("figure",null,[l("img",{src:"https://pic.imgdb.cn/item/62ecea698c61dc3b8ec00df9.jpg",alt:"master",loading:"lazy",decoding:"async"})],-1)),i[103]||(i[103]=l("h2",{id:"分支原理",tabindex:"-1"},[t("分支原理 "),l("a",{class:"header-anchor",href:"#分支原理","aria-label":'Permalink to "分支原理"'},"​")],-1)),i[104]||(i[104]=l("h3",{id:"git-refs-目录",tabindex:"-1"},[t(".git/refs 目录 "),l("a",{class:"header-anchor",href:"#git-refs-目录","aria-label":'Permalink to ".git/refs 目录"'},"​")],-1)),i[105]||(i[105]=l("p",null,"这个目录中保存了分支及其对应的提交对象",-1)),i[106]||(i[106]=l("h3",{id:"head-引用",tabindex:"-1"},[t("HEAD 引用 "),l("a",{class:"header-anchor",href:"#head-引用","aria-label":'Permalink to "HEAD 引用"'},"​")],-1)),i[107]||(i[107]=l("p",null,"当运行类似于 git branch (branchname) 这样的命令时，Git 会取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的 任何新分支中。",-1)),i[108]||(i[108]=l("p",null,"当你执行 git branch (branchname) 时，Git 如何知道最新提 交的 SHA-1 值呢？ 答案是 HEAD 文件。",-1)),i[109]||(i[109]=l("p",null,"HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分 支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值。 它是一个指向其他引用的指针",-1))]),"main-header":n(()=>[s(e.$slots,"main-header")]),"main-header-after":n(()=>[s(e.$slots,"main-header-after")]),"main-nav":n(()=>[s(e.$slots,"main-nav")]),"main-content":n(()=>[s(e.$slots,"main-content")]),"main-content-after":n(()=>[s(e.$slots,"main-content-after")]),"main-nav-before":n(()=>[s(e.$slots,"main-nav-before")]),"main-nav-after":n(()=>[s(e.$slots,"main-nav-after")]),comment:n(()=>[s(e.$slots,"comment")]),footer:n(()=>[s(e.$slots,"footer")]),aside:n(()=>[s(e.$slots,"aside")]),"aside-custom":n(()=>[s(e.$slots,"aside-custom")]),default:n(()=>[s(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{C as default};
