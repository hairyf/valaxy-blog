[{"title":"Valaxy 主题 Hairy","tags":["valaxy","theme","教程"],"categories":"Valaxy Theme Hairy","author":"毛先生","excerpt":"\n<HairyImage class=\"rounded w-full h-150\" fit=\"contain\" src=\"/preview.png\" />\n\n最初使用 [Vuepress](https://www.vuepress.cn/) 搭建了一个博客，主要用于记录学习笔记，为了方便直接采用了 gitee pages 进行部署。后面想要一个更加个性化的博客。尽管 [Vuepress](https://www.vuepress.cn/) 在文档功能上表现出色，但其定制复杂且功能集成度有限，许多功能需要自己动手实现。\n\n之后我发现了 [Valaxy](https://valaxy.site/) 它的设计理念与我的需求十分相似符合，加上近期 gitee pages 频繁告警文章敏感内容，难以排查（主要原因? ）博客几乎处于瘫痪状态，因此我决定转向 Valaxy 定制博客。\n\nValaxy 在官网中所描述，Valaxy = V + Galaxy 旨在成为下一代静态博客框架，提供更好的热更新与用户加载体验，它不像传统的文档系统，内置了更多博客相关的 API，为博客开发提供了更强大更便捷的自定义开发可能性。\n\n","link":"/posts/theme"},{"title":"主题配置","tags":["valaxy","教程"],"categories":"Valaxy Theme Hairy","author":"毛先生","excerpt":"\n通过修改 valaxy.config 的 themeConfig 字段，可以修改部分主题部分。\n\n```ts\nimport { defineConfig } from 'valaxy'\nimport type { ThemeConfig } from 'valaxy-theme-hairy'\nexport default defineConfig<ThemeConfig>({\n  theme: 'hairy',\n\n  themeConfig: {\n    // ...\n  },\n})\n```\n\n## 主页配置\n\n```json\n{\n  // 修改此列表更改主页轮播图使用的图片列表\n  // 默认使用 hairy 内置的图片列表\n  \"images\": [/* your image urls */]\n}\n```\n\n\n## 文章配置\n\n\n```json\n{\n  \"layout\": {\n    \"post\": \"image:slice:reverse\"\n  }\n}\n```\n\n","link":"/posts/theme/step-1"},{"title":"界面配置","tags":["valaxy","教程"],"categories":"Valaxy Theme Hairy","author":"毛先生","excerpt":"\n## 文章分类\n\n分类用于归类系列文章。\n\n- 一级分类\n\n```md\n---\ntitle: 标题\ncategories: Valaxy Theme Hairy\n---\n```\n\n- 多级分类\n\n```md\n---\ntitle: 标题\ncategories: \n  - aaa\n  - bbb\n  - ccc\n---\n```\n\n","link":"/posts/theme/step-2"},{"title":"特殊功能","tags":["valaxy","教程"],"categories":"Valaxy Theme Hairy","author":"毛先生","excerpt":"\n:::info\n以下介绍可以使用的 markdown 或者 html 标签。\n\n功能大部分基于 `markdown-it` 插件与 `theme/components` 中的组件。\n:::\n\n## links 链接\n\n基于 theme components，用来建立友链或其他网址链接功能。\n\n使用 `HairyLinks` 标签、字段包含\n\n\n|  字段  | 名称 | 必填 |\n|----|---|---|\n| name  | 名称 | 是 |\n| url   | 地址 | 是 |\n| image | 图片 | 是 |\n| color | 颜色 | 是 |\n| desc  | 描述 | 否 |\n\n","link":"/posts/theme/step-3"},{"title":"2022 年的一些思考","tags":["think"],"categories":[],"author":"毛先生","excerpt":"\n回顾我生命中的旅程，这是我今年的所得感想。自 2018 年起，决定踏入这个行业，命运的齿轮便开始不停地转动。每当回想起我所经历的一切，只是一种希望能够延续的挣扎，渴望齿轮继续转动而已。\n\n","link":"/posts/think/2022"},{"title":"2024 年，随着年龄的增长","tags":["think"],"categories":[],"author":"毛先生","excerpt":"\n<h3 class=\"my-10 text-center\">我想把这一切 当做旅程的一部分</h3>\n\n<meting-js type=\"song\" theme=\"var(--hy-c-primary)\" server=\"netease\"  id=\"1881866975\" autoplay=\"true\" />\n\n<div class=\"my-10 text-center\">\n \n</div>\n\n\n#### 时光荏苒，转眼来到 2024 年的七月。回首往事，不禁自问，已经成为一个合格的大人了吗？我不知道，但随着时间的增加，我面临了更多挑战，是人、家人、还是事，甚至是我\n\n#### 我虽不善辞令，却谋生已近五载。生命总计不算长亦不算短，在这里历经诸多波折，频繁跳槽、搬迁，每一次似乎都是一场巨大的挑战，然而我却感到束手无策\n\n#### 还有朋友许多，虽然联系不多，但我们一起，无论任何事情。尽管有着距离，但彼此间的尊重和理解如同家人，令人感到安心。原来，一直陪伴我的孤独正是你们\n\n#### 突然放假，便决定前往长沙游玩，与老友相聚，做着平常做的事情，暂时忘却烦恼。然而归来却是裁员，自己如同沙漠中的一粒尘埃，风暴袭来，却无处躲藏\n\n#### 至于现在，我不讨厌工作，但感到不安。边界感逐渐模糊，思想上的疲累和脑海中的倦怠让我不愿过多投入。但考虑到薪和闲时，我仍然选择坚持。我不满现状，依然渴望在工作中有所作为\n\n#### 一同参观动漫展，发现他的状态不如从前，消瘦许多。我心生忧虑，我想了很多想说，但什么都没说，玩的很累，但心灵不累，朋友离去，我陷入深思\n\n#### 重要的是什么？我所思的又是什么？她/他在东西方面又遇到了什么困境？总之，我感到疲惫不堪，思绪纷乱。或许，此刻我需要的是一份睡眠，一缕明亮的光芒，指引我走出困境，找回内心的平静\n\n","link":"/posts/think/2024"},{"title":"随记 - 近况","tags":["blog"],"categories":"Daily","author":"毛先生","excerpt":"\n<meting-js type=\"song\" theme=\"var(--hy-c-primary)\" server=\"netease\"  id=\"2071193941\" autoplay=\"true\" />\n\n## 近况 And 练琴\n\n工作原因，近一年转居家办公后的状态感觉比较差，虽然薪资、生活还算过得去，因为居家办公，已经快一个多月没有现实中跟人交流了，心情摇摆不定，陷入了种种的迷茫，每晚都难以入睡。\n\n来深圳这么久了到如今，什么也没有抓住，但又不想就这样放弃回老家。所以最近正在积极的练琴、组乐队，希望能在这里找到待下去的理由。\n\n另外插播一句，我真的很喜欢我的电吉他，好帅好好看！\n\n<!-- 图片 -->\n<hairy-image class=\"w-2xl\" src=\"/follow-me/1.jpg\" />\n\n","link":"/posts/think/follow-me"},{"title":"初入职场工程师的一些思考","tags":["think"],"categories":[],"author":"毛先生","excerpt":"\n作为初入职场的小白，性格也直来直往，近几个月确实也发现了自己在职场交流中处处冒犯，作为职场人，能力虽然很重要，但人际交往也往往不能忽视，如何与上司和同事打好关系至关重要。\n\n","link":"/posts/think/rules"},{"title":"致曾经伤感的自己","tags":["think"],"categories":[],"author":"毛先生","excerpt":"\n<div class=\"flex-center my-48px\">\n  <audio controls src=\"/songs/homesick.mp3\" autoplay />\n</div>\n\n\n曾几何时认为爱就只是简简单单，互相喜爱，携手相伴。事宜如今年纪也不小了（其实也不大），回过头发现自己是多么的幼嫩，最近看了《败犬女主太多了！》有感而发。\n\n败犬是一部氛围清新、愉快的夏日日式小清新作品，而说起夏日，我就莫名地感受到一股悲伤，我总是想到残夏，想到八月的末尾，想起挥手告别、轻吐「再见」的人们。\n\n::: info 男主独白\n据说70%的高中生情侣会在一年之内分手，\n\n若连毕业后的也算上，几乎可说算是全军覆没，\n\n但所有人依然投身于恋爱的折腾，时而哭泣，时而欢笑。\n\n我并不期望现实和自己的内心会被这种短暂的关系动摇，\n\n但我有时候会想，\n\n要是我有那种青春的话，\n\n要是眼前有会为我流泪的女主角的话，\n\n要是我是轻小说男主角的话，\n\n那个时候，我会有什么感觉呢。\n:::\n\n","link":"/posts/think/sentimental"},{"title":"睡眠日记 - 7 月","tags":["sleep","blog"],"categories":"Daily","author":"毛先生","excerpt":"\n近期睡眠质量很差，7 月中旬去医院门诊检查，通过网络、以及医生的建议，每天起床可以记录一下睡眠状况，所以在这里记录一下每天的睡眠状况。不知道会不会有人觉得比较矫情，失个眠而已还要去医院看，但的确长期来说也影响了工作生活，我也希望生活品质能有所提升，不像现在死气沉沉的，所以就先从睡眠问题解决吧！\n\n","link":"/posts/think/sleep"},{"title":"Kemper（KPA）辅助输入","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n辅助输入允许将 Line 输出设备连接到 KPA，例如 MP3 播放器、平板电脑或采样垫或鼓机，使用外部音频文件或采样声音来 JAM。\n\n在现场表演中的声音，KPA 也可以用作入耳式集线器，可以通过 aux-in 接受监听信号，设置可以使用立体声。\n\nAux-in 信号通过 RETURN 输入和 ALTERNATIVE 输入。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63eb2d52f144a0100721088b.jpg\" />\n\n请注意，使用辅助输入功能时无法使用发送和返回功能。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63eb2d92f144a01007218e9a.jpg\" />\n\n辅助输入信号的音量在输出菜单中设置，可以在其中找到 3 个选项。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63eb2dcff144a01007220178.jpg\" />\n\nAux In > Main: 在主输出中辅助输入信号的音量\nAux In > Monitor: 在监听输出中辅助输入信号的音量\nAux In > Headph: 在耳机中辅助输入信号的音量\n\n","link":"/posts/music/kpa/auxiliarry-in"},{"title":"Kemper（KPA）效果循环","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\nKPA 可以在吉他和 KPA 直接连接一个或多个单块修改器，但如果将其放在 KPA 的效果链中间，就可以保持这个单块的状态，并通过 remote 进行控制。\n\n为此，得先使用后面版上的 send 和 return 来连接单块修改器。\n\n<hairy-image style=\"max-width: 800px\" src=\"https://pic.imgdb.cn/item/63e39b874757feff338e5414.jpg\" />\n\n使用 STOMPS 或 EFFECTS 中的一个位置放置单块并激活效果循环\n\n<hairy-image style=\"max-width: 800px\" src=\"https://pic.imgdb.cn/item/63e39bd64757feff338f0c2c.jpg\" />\n\n一般有三种不同类型的循环单块。\n\n","link":"/posts/music/kpa/external-effects"},{"title":"Kemper（KPA）输入","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n<hairy-image style=\"display: block\" src=\"https://p7.itc.cn/q_70/images03/20220927/2fcfb88c2936415bb9b05442cdc21079.jpeg\" />\n\n大概十多年前，以Fractal Audio、KPA 为代表的新一代数字类综合效果器开始流行起来，这些尖端的数字类效果器，均可以让乐手在没有实体箱头、单块效果器的情况下完成演出、录音以及练习，再也不用为演出现场品质参差不齐的音箱设备而烦恼，只需设置好音色并保存，直接调用即可。\n\n而Kemper Profiling Amplifier（简称KPA）的诞生，将吉他手们长期以来所期待的变成了现实，真正开启了“音色克隆”时代。\n\nKPA采用前沿的专利数字技术来捕捉电子管音箱（吉他/贝司）的音色DNA，这个过程即叫做“Profiling”，与普通数字建模僵硬、静态的效果不同，它能够得到和原始音箱一样生动、多维度、且动态十足的音色表现，原汁原味，即使让专业人员进行A/B盲测也听不出区别。\n\nKPA出厂预装了相当丰富的音色库，汇集了来自全球顶级品牌音箱的音色，由顶尖工程师在专业工作室中制作，乐手们还可以从PC/Mac端的Rig Manager软件中找到数千个来自各地音乐人和工作室制作的采集音色，2012年至今，从无后级箱头（Head）、无后级机架（Rack）到带后级箱头（Powerhead）、带后级机架（Powerrack），再到后来的落地版KPS，KPA已经建立了一个相当庞大且优质的音色库。\n\n","link":"/posts/music/kpa/input"},{"title":"Kemper（KPA）循环录音机","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":" \n将循环录音机放置在信号流不同的位置，需要按“SYSTEM系统”按钮，然后使用“PAGE页面”按钮翻到 Remote 设置页面：\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e5bb3d4757feff339ab780.jpg\" />\n\n屏幕的右上角则会显示循环录音机的位置。\n\n如果显示 `Looper Loc.: Pre` 则循环录音机直接在输出后面\n\n这意味着`<Stomp>``<Stack>` 和 `<Effect>` 这些模块的效果都没有被录制：\n\n`Input - Looper - Stomp - Stack - Effects - Output`\n\n当您要编辑音色而不必同时弹奏吉他时，可以使用 `Looper Loc.: Pre` 设置。\n\n如果设置 `Looper Loc.:Post`，循环录音机会录制整个信号链的内容，包括所有单块和效果。\n\n`Input - Stomp - Stack - Effects - Looper - Output`\n\n可以使用这种方法，首先录制一轨清音的信号，然后加入一轨失真音色。\n\n","link":"/posts/music/kpa/looper"},{"title":"Kemper（KPA）表演模式 - 基本","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n演出模式设计的目的是使用 KPA 进行现场表演，它可以让现场演出组织成 `125` 个**表演组**，而每个表演组可以包含 `5` 个不同的音色，KPA 称之为**插槽（slot）**\n\n常见且实用的组织方式是为每首歌创造一个独立的演出组，针对这首歌的不同部分，则可以使用五个不同的音色。\n\n","link":"/posts/music/kpa/mode-performance-baisc"},{"title":"Kemper（KPA）表演模式 - 编辑","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n表演模式要独立的储存空间，可以在浏览池中选择 625 个音色，用来组织以用于现场表演，表演模式中对音色的任何修改都不会影响浏览池中的原始音色。\n\n当音色从浏览池拷贝到表演组时，音色的名称会出现在选中的插槽中：\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63e470874757feff33b3cb15.jpg\" />\n\n> 在 REMOTE 显示屏上同样也会显示\n\n为了更好的组织表演设置，有两种方法可以修改音色名称：\n\n- 修改音色的实际名称\n  RIG NAME - Amp Profile\n- 修改插槽的名称（可更改为对应的歌曲部分或插槽用途来命名）\n  SLOT NAME - Songpart\n\n","link":"/posts/music/kpa/mode-performance-edit"},{"title":"Kemper（KPA）表演模式 - MIDI","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n在演奏模式下，可以发送 MIDI 程序更改，以切换外部效果设备上的预设。\n\n例如我们使用 KPA 通过 MIDI 来控制外部 Whammy 单块\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e4ae904757feff332f5bf8.jpg\" />\n\n当然也可以使用 KPA 内部的效果器来替代，不过也会有人想继续使用他们的单块效果器。\n\n在这种情况下，KPA 则扮演着集线器的角色，通过 MIDI 来控制外部设备。\n\nKPA 可以控制两个的外部效果器，通过连接 KPA 背面的 MIDI OUT 和 MIDI THRU：\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e4af444757feff3330a916.jpg\" />\n\n通过 MIDI 连接外部设备有许多选项，例如以串行方式连接多个设备：\n\n- Profiler MIDI Out --------- Effect 1 MIDI In (CH 1)\n- Effect 1 MIDI Out --------- Effect 2 MIDI In (CH 2)\n\n并将每个设备设置为不同的 MIDI 通道。\n\n要连接 2 个设备，应该将 KPA 的 MIDI OUT 连接到其中的 1 个，将 KPA 的 MIDI THRU 连接到另外一个设备的 MIDI In：\n\n- Profiler MIDI Out --------- Effect 1 MIDI In\n- Profiler MIDI Thru --------- Effect 2 MIDI In\n\n将 MIDI THRU 更改为第二个 MIDI 输出。\n\n","link":"/posts/music/kpa/mode-performance-midi"},{"title":"Kemper（KPA）噪音门","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n**噪声门的主要用途就是用来衰减低于阈值的信号，而这种被衰减的信号通常就是噪声。**在录音棚或者家庭录音室中，噪声门可以解决录音设备的底噪，电脑的风扇声，空调工作的声音，乐器串音，监听耳机的泄漏音等问题，当然，噪声门的处理对象远不止这些。 除了“消除”噪声，噪声门还可以用来塑造声音的动态包络，从而到达到某些效果，如增加冲击力等。\n\n","link":"/posts/music/kpa/noise-gate"},{"title":"Kemper（KPA）输出","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\nKPA 提供了多种输出，可以在录音或演出时使用，每一种输出都可以承载不同类型的信号\n\n首先，有立体声主输出，可以使用 TS 或 XLR 的插孔。\n\n<hairy-image style=\"max-width: 800px\" src=\"https://pic.imgdb.cn/item/63e368dc4757feff333769b5.jpg\" />\n\n旁边是直接输出和监听输出，并有独立的 TS 插孔。\n\n<hairy-image style=\"max-width: 800px\" src=\"https://pic.imgdb.cn/item/63e3692c4757feff3337f980.jpg\" />\n\nspdif 输出提供了以数字格式录音的方式，其采样率为 44.1KHz，分辨率为 24 位\n\n<hairy-image style=\"max-width: 800px\" src=\"https://pic.imgdb.cn/item/63e369904757feff3338a841.jpg\" />\n\n## Ground Lift（接地断开）\n\nKPA 为每个模拟输出以及返回输入提供了一个接地断开的开关，如果执行输出中，碰巧遇到了接地的嗡嗡声，按下相应的红色按钮，来解决这些问题。\n\n","link":"/posts/music/kpa/output"},{"title":"Kemper（KPA）并行路径","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n在 KPA 中，可以选择对音频使用并行路径，次功能会将信号流分为了个独立的路径\n\n- Path 1: Input - Stomp (A, B) - Output（输出）\n- Path 2: Input - Stomp (C, D) - Stack（音箱） - Effects - Output（输出）\n\n要激活平行路径选项，需要按 RIG 按钮进入音色菜单\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63e45afe4757feff3388cf53.jpg\" />\n\n使用 < PAGE > 按钮翻到第四页：Parallel signal path\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63e45c064757feff338ac39c.jpg\" />\n\n按第一个按钮激活平行路径\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63e45c334757feff338b17fc.jpg\" />\n\n“Parallel Path Mix” 允许在信号的两个部分之间进行平衡。\n\n","link":"/posts/music/kpa/parallel-path"},{"title":"Kemper（KPA）表情踏板","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n可以直接将表情踏板连接到 KPA，而 REMOTE 上有四个额外的表情踏板输入，出厂默认的踏板分配如下：\n\n- Pedal 1（Profiler） --------- Volume（音量）\n- Pedal 2（Profiler） --------- Morph（渐变）\n- Pedal 3（REMOTE） --------- Volume（渐变）\n- Pedal 4（REMOTE） --------- Morph（渐变）\n- Pedal 5（REMOTE） --------- Wah（哇音）\n- Pedal 5（REMOTE） --------- Pitch（音高）\n\n","link":"/posts/music/kpa/peals-profiler"},{"title":"Kemper（KPA）踏板与开关基础","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n要连接表情踏板，需要一条 TRS 电缆，也被成为立体声电缆\n\n<img src=\"https://pic.imgdb.cn/item/63e609f74757feff3314f1d4.jpg\" />\n\n单开关可以使用标准 TS 或单声道电缆连接\n\n<img src=\"https://pic.imgdb.cn/item/63e60a3b4757feff33156da7.jpg\" />\n\n> 如果使用双开关，则必须使用 TRS 电缆\n\n<img src=\"https://pic.imgdb.cn/item/63e60ad74757feff33169fae.jpg\" />\n\n尽管可以将最多六个踏板连接到 KPA 和 REMOTE，但使用踏板链接功能，则可以使用更少的踏板控制大多数事情。\n\n舞台上非常实用的设置是带有两个表情踏板的 REMOTE，第一个踏板控制音量，第二个踏板用于控制渐变、哇音和音高。\n\n<img src=\"https://pic.imgdb.cn/item/63e60b644757feff3317a419.jpg\" />\n\n要做的就是在音色中激活“Pedal Links 踏板链接” 将这些功能分配给踏板\n\n<img src=\"https://pic.imgdb.cn/item/63e60bb74757feff33183584.jpg\" />\n\n## External Foot Pedal（外部脚钉）\n\n如果想在没有 REMOTE 的情况下实用 KPA，理想配置是 1 个双踩开关和 1 个表情踏板的组合\n\n<img src=\"https://pic.imgdb.cn/item/63e60c2c4757feff33191aae.jpg\" />\n\n将开关和踏板接到 KPA 背后的开关/踏板输入 1 和 2：\n\n<img src=\"https://pic.imgdb.cn/item/63e60c714757feff3319a161.jpg\" />\n\n双踩开关可以控制两个功能，进入 SYSTEM 系统菜单，分配所需功能：\n\n<img src=\"https://pic.imgdb.cn/item/63e60cb54757feff331a2228.jpg\" />\n\n双踩开关最有用的配置是控制音色的上下切换。\n\n<img src=\"https://pic.imgdb.cn/item/63e60ce94757feff331a8811.jpg\" />\n\n左边选择下一个音色，右边选择前一个音色，在录音棚中，可以配置双踩开关的左开关激活调音表，用右开关敲击节拍。\n\n可以在系统菜单中使用 “polarity 极性” 参数更改开关的极性：\n\n<img src=\"https://pic.imgdb.cn/item/63e60d654757feff331b7560.jpg\" />\n\n可以使用单声道脚踩开关，例如 Boss FS 5U，并用单声道电缆连接它，只是要确保使用瞬时开关，而不用使用闭锁式开关\n\n<img src=\"https://pic.imgdb.cn/item/63e60d924757feff331bcce3.jpg\" />\n\n","link":"/posts/music/kpa/perimeter-controls"},{"title":"Kemper（KPA）纯箱体","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":" \n\n典型的通过麦克风拾取吉他箱体的声音，使用全频监听时，高频段会比较刺耳，在舞台上使用入耳式监听时同样存在这个问题。\n\nKPA将其作为克隆过程的一部分，准确地再现此声音：\n\nProfiling：\n\nAmp     Cabinet     Microphone\n\n“Pure Cabinet纯箱体”通过消除这些有问题的频率：\n\nPure Cabinet：\n\nAmp     Cabinet\n\n使这些放大器克隆的声音听起来正常。\n\n","link":"/posts/music/kpa/pure-cabinet"},{"title":"Kemper（KPA）重新放大","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n如果我们有类似 KPA “Direct 直接输出” 录制的吉他声音，可以使用音箱克隆对齐进行“重新放大”，转换为适合的吉他音色，而 KPA 支持实现重新放大，无需任何其他设备，简单的将其连接到声卡即可。\n\n","link":"/posts/music/kpa/reamping"},{"title":"Kemper（KPA）音色管理器","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":" \n\n可以从 Kemper 官方网站下载音色管理器软件，确保根据您的计算机操作系统，选择正确的版本。\n\n<img src=\"https://pic.imgdb.cn/item/63e5cc1d4757feff33b27d6e.jpg\">\n\n建议最好使用最新版本的 Rig Manager 和 KPA 操作系统。\n\n安装完音色管理器后。需要输入作者姓名和 Kemper 账号登录信息。\n\n现在即可以将音色从 KPA 复制到本地库，并通过音色管理器访问音色交换平台。\n\n打开音色管理器的偏好设置 `Preferences`，选择通用标签页，输入在 KPA 中使用的作者名称。\n\n可以在 kPA 的 SYSTEM 系统菜单中的 Owner 页面找到该名称。\n\n<img src=\"https://pic.imgdb.cn/item/63e5cd634757feff33b42a48.jpg\">\n\n请确保在 KPA 和音色管理器中使用完全相同的名字，包括大小写，只有这样，在 KPA 和音色管理器中，个人音色和收藏音色才会一致。\n\n在点击 Rig Exchange，使用官网注册的用户名账号和密码。\n\n","link":"/posts/music/kpa/rig-manager"},{"title":"Kemper（KPA）分体音箱 - 放大器","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n\n在“Stack 音箱”菜单中，可以找到几个选项来微调所使用的音箱克隆。\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e38c914757feff3375c743.jpg\" />\n\n按住 AMPLIFIER 键约一秒钟以显示“amp 放大器”菜单\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e38cf24757feff337667f5.jpg\" />\n\n- Clarity（清晰度）\n\n对于缺乏清晰度的高增益音色，“Clarity 清晰度”可以使声音更清晰，不那么糊。\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e38d4a4757feff3376f2f1.jpg\" />\n\n在高增益音色下，即使用到六根弦的和弦启用清晰度后也可以轻松区分。\n\n","link":"/posts/music/kpa/stack-amplifier"},{"title":"Kemper（KPA）分体音箱 - EQ均衡","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n\n要显示 EQ 菜单，按住 EQ 键约一秒钟以显示。\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e393d14757feff3382255c.jpg\" />\n\n每一个克隆文件都提供四段均衡：低音、中音、高音、极高频。\n\n\n## EQ Post（EQ 后）\n\nKPA 可以选择更改均衡器的位置，在大多数放大器中，可以将其放置在增益级的前面或后面，当均衡器位于增益器的后面时，所对均衡器的任何改动，只会对声音的频段产生影响，而不会对失真度产生影响。\n\n<hairy-image style=\"max-width: 1200px\" src=\"https://pic.imgdb.cn/item/63e395214757feff33845445.jpg\" />\n\n对其 EQ 子项左旋转，将衰减该频段的音量，右旋转则会提升相应的音频。\n","link":"/posts/music/kpa/stack-eq"},{"title":"Kemper（KPA）脚踏开关","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n如果要在没有 REMOTE 的情况下使用 KPA，可以将双踩开关直接连接到 KPA，要切换音色，只需要使用 TRS 电缆将双踩开关连接到 KPA 背面的输入。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63ea04ea4757feff33708e52.jpg\" />\n\n然后需要配置脚踩开关，为此，按系统按钮，并翻页到“Pedal 1 踏板 1”的设置。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63ea053d4757feff33732970.jpg\" />\n\n如果要连接双开关，将 Mode 设置为 Profiler Switch，将 A 设置为“Rig Up 音色上”，将 B 设置为 “Rig Down 音色下”。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63ea05d84757feff3377e6c7.jpg\" />\n\n这就是音色选择开关的设置，设置后即可通过脚踩开关切换音色。\n\n","link":"/posts/music/kpa/switches"},{"title":"Kemper（KPA）音量&推子踏板","tags":["Kemper"],"categories":["Music","Kemper"],"author":"毛先生","excerpt":"\n如果使用音量踏板功能，需要连接表情踏板，要么连接到 REMOTE 上，要么连接到 KPA 背后的 Switch/Pedal 开关/踏板插孔上。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63eb3309f144a010072c5429.jpg\" />\n\n按 System 按钮，翻页到对应的踏板页面，这里将踏板连接到了 REMOTE 上的 3 号孔，所以我们翻到 Padal 3 上。\n\n将 Mode 设置为 Pedal Type 1，适用于所有标准的表情踏板，将 Function 设置为 Volume Pedal（音量踏板）现在，可以通过连接的表情踏板控制所有音色的音量。\n\n可以单独为每一个音色的音量踏板设置两个参数，按下 RIG 按钮，然后使用 PAGE 按钮转到音量踏板设置页面。\n\n","link":"/posts/music/kpa/volume-boost-pedal"},{"title":"Music：おくすり飲んで寝よう","tags":["song"],"categories":["Music","Song"],"author":"毛先生","excerpt":"\n<h3 class=\"my-10 text-center\">吃完药就睡觉吧，晚安</h3>\n\n<meting-js type=\"song\" theme=\"var(--hy-c-primary)\" server=\"netease\"  id=\"1989905180\" autoplay=\"true\" />\n\n<div class=\"text-center mt-10 hidden\">\n  从小时候开始错过呢\n\n  闪闪发光哟 吃了药去睡吧\n\n  就算傻傻的发呆也没关系哦\n\n  孤独地 冇问题\n\n  小小的大人对薄饼沾沾自喜\n\n  生病了呢 所以吃了药再睡吧\n\n  虽然不是吃了就会好 但还是试试药吧？\n\n  吃着同样的食物(怠惰怠惰怠惰)\n\n  听着同样的音乐(为咩为咩为咩)\n\n  做着同样的事情(懒洋洋懒洋洋)\n\n  和土壤睡在一起\n\n  不要说再见呀\n\n  找到特效药的话\n\n  就用欺诈的梦点缀吧\n\n  日记本不过是垃圾箱\n\n  赶快，真急躁呢\n\n  想象，真嘈杂呢\n\n  相当，急匆匆呢\n\n  自言自语自说自话\n\n  从小开始就假装是奇怪的人\n\n  现在变得扭扭捏捏的\n\n  是这样呢 不是这样 够了啦\n\n  孤独地 冇问题\n\n  从小时候开始就 好啦 好啦\n\n  吐出来扔出去啦 然后吃药睡觉吧\n\n  磊磊落落 想要轻松地活着啊 可是有问题\n\n  小小的大人正在dance nice\n\n  生病的原因啦 所以吃了药去睡觉吧\n\n  虽然不是吃了就会好 但总归要试试吧？\n\n  从小时候开始就错过呢\n\n  闪闪发光的呢 吃了药去睡觉吧\n\n  就算笨笨的发呆也没关系啦\n\n  孤独地 冇问题\n\n  小小的大人对薄饼洋洋自得\n\n  因为生病了呢 所以吃了药去睡吧\n\n  虽然不是吃了就会好 但还是试试吧？\n</div>\n\n","link":"/posts/music/song/%E3%81%8A%E3%81%8F%E3%81%99%E3%82%8A%E9%A3%B2%E3%82%93%E3%81%A7%E5%AF%9D%E3%82%88%E3%81%86"},{"title":"Music：サヨナラ深夜ちゃん","tags":["song"],"categories":["Music","Song"],"author":"毛先生","excerpt":"\n<div class=\"my-10 text-center\">\n  久违听到这首歌才知道 しゃべる帽子 已经不更新了，感到惋惜 ´‸` 明天要去医院复诊，给自己留个好心情，晚安~\n</div>\n\n<meting-js type=\"song\" theme=\"var(--hy-c-primary)\" server=\"netease\"  id=\"1454713055\" autoplay=\"true\" />\n\n\n<div class=\"text-center mt-10 hidden\">\n  如果你能被我的歌声所拯救的话\n\n  那真是太好了\n\n  虽然离别叫人感到悲伤\n\n  但总有一天还会再想起的\n\n  谢谢你 即便如此 我也曾幸福过\n\n  与你相遇这件事以及 眼泪濡湿枕头的夜晚也\n\n  对不起 心灵这么脆弱 但是你和我不同\n\n  一定是不同的\n\n  坚强地活下去吧在我这短暂的人生之中\n\n  发生的并不全是好事\n\n  但那些许许多多的琐碎小事\n\n  看起来却很是美好\n\n  我做了许多 让你感到无聊的事吧\n\n  很自以为是这一点以及 净说些不好的话这一点也\n\n  即使不是我的歌 也有其他好歌的\n\n  有着那些歌 请别让你的笑容消失啦…谢谢你 即便如此 我也曾幸福过\n\n  与你相遇这件事以及 眼泪濡湿枕头的夜晚也\n\n  对不起 心灵这么脆弱 但是你和我不同\n\n  一定是不同的\n\n  坚强地活下去吧\n\n  所以啊\n\n  我做了许多 让你感到无聊的事吧\n\n  很自以为是这一点以及 净说些不好的话这一点也\n\n  即使不是我的歌 也有其他好歌的\n\n  有着那些歌 请别让你的笑容消失啦\n</div>\n\n","link":"/posts/music/song/%E3%82%B5%E3%83%A8%E3%83%8A%E3%83%A9%E6%B7%B1%E5%A4%9C%E3%81%A1%E3%82%83%E3%82%93"},{"title":"Music：悶々ふぁんもおらん","tags":["song"],"categories":["Music","Song"],"author":"毛先生","excerpt":"\n<h3 class=\"my-10 text-center\">吡~吡~</h3>\n\n<meting-js type=\"song\" theme=\"var(--hy-c-primary)\" server=\"netease\"  id=\"2032819101\" autoplay=\"true\" />\n\n<div class=\"text-center mt-10 hidden\">\n  这个是这个是脑内喃喃\n\n  没粉丝而忧郁\n\n  这个是这个是疼痛等级\n\n  能言语的biangbiang面\n\n  让我看让我看到你信仰心\n\n  这是我这是我和从烦闷中逃离\n\n  好可爱好可爱（握紧拳）新敌人出现\n\n  天地异变也光鲜亮丽的社交软件\n\n  多么的多么的愚蠢无意义\n\n  为何要为何要弄成这副德行\n\n  看看吧听听吧并不可怕呀\n\n  看看吧听听吧并不可怕呀\n\n  这个是这个是脑内喃喃\n\n  没粉丝而忧郁\n\n  这个是这个是疼痛等级\n\n  能言语的biangbiang面\n\n  让我看让我看到你信仰心\n\n  这是我这是我和从烦闷中逃离\n\n  这是你和我的可能性的不安定摇晃\n\n  核融合的life\n\n  认真反而可能渐渐\n\n  艰辛淡淡“面倒”（麻烦）起来\n\n  我有啊我有啊竹子啃就行\n\n  忧郁啊忧郁啊反反复复不停\n\n  看看吧听听吧并不可怕呀\n\n  看看吧听听吧并不可怕呀\n\n  这个是这个是很重要的\n\n  没粉丝而忧郁\n\n  这个是这个是胡胡胡的\n\n  最喜欢的大四喜\n\n  没网络和夜晚都太过艰辛\n\n  很久前很久前就已睡眠麻痹\n\n  这个是这个是脑内喃喃\n\n  没粉丝而忧郁\n\n  这个是这个是疼痛等级\n\n  能言语的biangbiang面\n\n  让我看让我看到你信仰心\n\n  这是我这是我和从烦闷中逃离\n</div>\n\n","link":"/posts/music/song/%E6%82%B6%E3%80%85%E3%81%B5%E3%81%81%E3%82%93%E3%82%82%E3%81%8A%E3%82%89%E3%82%93"},{"title":"基本乐理（音乐概念）","tags":["Music theory"],"categories":["Music","Music theory"],"author":"毛先生","excerpt":"\n声音是由物体的震动产生的，不同材质，不同形状的物体发生震动，它的音色是不同的。比如男人与女人说话的声音，虽然材质相同，但由于男女声带结构不一样，所以音色也不一样，在比如中国大鼓是皮革，三角特是金属的，材质不一样，音色差别很大，就算是同样皮革做成的鼓，大小尺寸不一样，音色也不一样，大一点的更厚重，小一点的更清脆。\n\n","link":"/posts/music/theory/1-basic"},{"title":"基本乐理（音律、十二平平均律、分区、音域）","tags":["Music theory"],"categories":["Music","Music theory"],"author":"毛先生","excerpt":"\n所谓音律，就是在音乐体系中，各音的绝对准确高度以及互相之间的关系，现在全球公认适用最广泛的音律是十二平均律，我们学习的乐理知识，也基本是以十二平均律为前提的知识，在很久很久以前，古希腊人就提出了十二平均律，但没有科学的计算，直到 1584 年，我国明朝大音乐家朱载堉，用数学的方法定制了十二平均律，这也是全球最早的科学计算的十二平均律。\n\n","link":"/posts/music/theory/2-temperament"},{"title":"基本乐理（调式、自然大调）","tags":["Music theory"],"categories":["Music","Music theory"],"author":"毛先生","excerpt":"\n音乐里用到的音们，总是按照一定的关系连接在一起，这种按照一定关系连接在一起的许多音组成的、以一个主音为中心的体系，叫做调式。\n\n而调式里的 “式” 可以理解成 “形式”，指的是排列规则和逻辑。\n\n## 音阶\n\n调式中，按照高低次序、按从主音开始再到主音排列起来的音们，叫做音阶。\n\n## 大调式、自然大调\n\n大调式是浩如烟海的调式中，比较常见的一个类型中的一种，这个类型叫 “大调式”。\n\n大调式是三种调式的总称，他们分别是和声大调、自然大调、旋律大调，其中**自然大调**是大调式的基本形式，和声大调和旋律大调都是根据它演变而来的。\n\n","link":"/posts/music/theory/3-mode"},{"title":"基本乐理（简谱）","tags":["Music theory"],"categories":["Music","Music theory"],"author":"毛先生","excerpt":"简谱是用来记载音乐的一个符号系统，音乐是由音调、响度、音色、长短组成的，其中音调和长短能决定音乐的样子，所以简谱实际是用于记载**音调**和**长短**的系统。\n\n简谱通常会和 “首调唱名法” 配合使用，这样会对吉他来讲更加方便。\n\n简谱会用数字 1、2、3、4、5、6、7 来表示一个调中的 1 级到 7 级。\n\n比如用简谱表示 D 大调的话，D 调的 1~7 级分别是 D、E、F#/Gb、G、A、B、C#/Db，那么对应的简谱数字代表 1 ~ 7级一一对应\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63f323ebf144a01007634c1a.jpg\" />\n\n所以 D 简谱里的数字 1 代表 D 音、数字 2 代表 E 音，依次类推排序。\n\n而简谱里的数字只代表音级，每个数字具体是啥音、得看这个简谱是啥调，通常简谱的左上方会写着 `1=C`。\n\n1 即代表 1 级、右边的字母则是 12 平均律的任何一个音，所以这段等式翻译成中文，即是 1级（主音）是 C\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63f324b6f144a010076460c9.jpg\" />\n\n","link":"/posts/music/theory/4-spectrum"},{"title":"基本乐理（吉他指板）","tags":["Music theory"],"categories":["Music","Music theory"],"author":"毛先生","excerpt":"\n在吉他六根弦的空弦音都是标准音的前提下，从六弦到一弦每个弦的空弦音分别是 E2、A2、D3、G3、B3、E4\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63f37aadf144a01007f393d3.jpg\" />\n<hairy-image src=\"https://pic.imgdb.cn/item/63f37a6cf144a01007f2db9e.jpg\" />\n\n虽然每个品格的宽度不同，但每个品格与挨着它的品格都相差半音。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63f37bd0f144a01007f6a805.jpg\" />\n\n他们的关系有着某种规律，除了三弦是升高三半音，其他都是升高四半音。\n\n<hairy-image src=\"https://pic.imgdb.cn/item/63f37c3cf144a01007f7d5b8.jpg\" />\n\n只要跟着十二平均律下跳过重复的音，重复弹即是十二平均律的连续音：\n\n","link":"/posts/music/theory/5-fingerboard"},{"title":"所有把位的 C 大调音阶","tags":["Music theory"],"categories":["Music","Utils"],"author":"毛先生","excerpt":"\n‌C大调自然音阶‌是由七个基本音符组成的音阶，这七个音符依次为 C, D, E, F, G, A, 和 B。这个音阶的特点是每两个相邻音之间的音程关系依次为全音（大二度）和半音（小二度），具体为“全全半全全全半”的关系。C大调自然音阶在音乐理论中被视为最基本、最常用的音阶之一，因为它以C音作为主音或基准音，由7个音符组成，形成一个完整的8度。这个音阶在键盘乐器上按照白键进行排列，非常方便学习和演奏，具有稳定和和谐的感觉。C大调自然音阶在音乐创作和演奏中具有广泛的应用，许多经典的音乐作品都采用了C大调音阶作为基础。学习和掌握C大调自然音阶对音乐爱好者来说是非常有益的，它不仅可以帮助我们熟悉和掌握基本的音乐理论和键盘演奏技巧，还能提高音乐感知能力和听觉记忆力，为后续的音乐学习打下坚实的基础，同时为音乐创作提供更多的灵感和可能性‌。\n\n在吉他上，C大调的把位可以通过不同的指型来学习和掌握。这些把位不仅包括基本的指型，还包括高把位的和弦指法，帮助演奏者更全面地掌握C大调的音阶和和弦。以下是一些关键的把位信息：\n\n- 基本把位指型‌：\nC大调的第一把位指型起始音是C音，也可以根据指型的起始音来命名，例如，以C音为起始音的指型称为Re指型，因为它以D音（Re的上方全音）开始。同样地，以G音起始的指型称为Si指型，因为它以A音（Si的上方半音）开始。这样的命名有助于记忆和理解各个把位指型的特征‌1。\n- 高把位和弦指法‌：\n对于高把位的和弦，可以通过特定的指法来安排，这些指法汇总需要花费一定的时间来练习和掌握。通过床上的练习，可以逐渐熟悉和掌握这些高把位的技巧，从而提高演奏技巧‌2。\n- 五声音阶练习‌：\n\n为了熟悉五声音阶的各个把位，首先需要知道每个把位具体的弹法。以C大调为例，五声音阶的练习包括五个基本把位，从C音开始的五个把位指型，通过串联练习，可以全面熟悉整个吉他指板上的五声音阶，为即兴演奏等打下基础‌。\n\n","link":"/posts/music/utils/all-c-major"},{"title":"吉他指板工具（找音）","tags":["Music theory"],"categories":["Music","Utils"],"author":"毛先生","excerpt":"\n吉他的每个品，对应的一个音，分别是 CDEFGAB（1234567）并包含半音。\n\n记住吉他每个品对应着什么音，就像学习英文单词，只有熟系了指板的每一个音，才能知道自己弹的是什么，才能熟练的掌握更多的技能，例如和弦、和声进行、和弦音、音阶的运用等。\n\n但自己对应的去找每个音去死记硬背是一件很困难的事情，所以我做了几个小工具，从现在开始，每天记住一个音，逐步的增加难度，成为吉他高手！\n\n","link":"/posts/music/utils/memory-fingerboard"},{"title":"Git 高级概念应用(CRUD)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n## 初始化仓库:`git init`（初始化）\n\n**作用**：初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要 的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化 好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。\n\n工作目录下面的所有文件都不外乎这两种状态**：**已跟踪** 或 **未跟踪**。\n\n已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它 们的记录，工作一段时间后，它们的状态可能是**已提交**，**已修改**或者**已暂存**。\n\n所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在 当前的暂存区域。\n\n初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态 为已提交；在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把 这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文 件。使用 Git 时的文件状态变化周期如下图所示\n\n","link":"/posts/notes/git/advanced"},{"title":"Git 基础概念应用","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\ngit 地址 : https://git-scm.com/download/win，下载完安装包之后，双击 exe 安装包，可以看到如下图窗口界面，一直点击下一步，就安装完成了。\n\n","link":"/posts/notes/git/basic"},{"title":"Git 分支控制","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。\n\n对于大项目来说，这样的过程会耗费很多时间。\n\n而 **Git 的分支模型极其的高效轻量的。是 Git 的必杀技特性**，也正因为这一特性，使 得 Git 从众多版本控制系统中脱颖而出，为你创建了一个可以移动的新的指针。 \n\n","link":"/posts/notes/git/branch"},{"title":"Git 项目命令集","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n一般情况下，`git add`、`git commit` 其实都是一些基层指令的集合\n\n- git add\n\n  > `git add ./`  将目录下所有文件进行以下操作(存入项目对象，在存入暂存区)\n  >\n  > ↓\n  >\n  > `git hash-object -w 文件名`\t(修改了多少个文件目录中的文件，次命令就要被执行多少次)\n  >\n  > \t↓\n  >\t\n  > \t`git ipdata-index ....` \t\t(存入暂存区)\n\n- git commit\n\n  > `git commit -m \"注释内容\"`  暂存区存入数据库，并对应创建树对象，提交对象\n  >\n  > ↓\n  >\n  > `git write-tree`\t\t创建树对象\n  >\n  > \t↓\n  >\t\n  > \t`git commit-tree`\t  提交对象\n\n","link":"/posts/notes/git/commands"},{"title":"Git 文件忽略(gitignore)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪 文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临 时文件等。我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件模式。\n\n","link":"/posts/notes/git/config"},{"title":"Git 统一代码风格(eslint)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\nGit 中结合 Eslint。让代码在没有通过 Eslint 的情况下 禁止提交（pre-commit 、husky、eslintignore）\n\n","link":"/posts/notes/git/eslint"},{"title":"Git 分布式版本控制系统","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。\n\n","link":"/posts/notes/git"},{"title":"Git 回退与指针","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"Git 强大的撤销、版本回退功能，让我们在开发的过程中能够随意的回到任何一个时间点的状态，本文将从如下三个方面介绍 Git 中的后悔药：\n\n- 工作区的代码想撤销\n- add 到暂存区的代码想撤销\n- 提交到本地仓库的代码想撤销\n\n","link":"/posts/notes/git/regret"},{"title":"Git 远程仓库(remote)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n在实际工作中，往往使用一台服务器充当版本库的载体，这台服务器 24 小时开机，其他用户从服务器的版本库克隆一份到自己的电脑上，并且将各自的提交推送到服务器仓库中，也从仓库中拉去别人的提交。但自己搭建Git的服务器也不是很方便，也没有必要。我们往往使用一些第三方机构提供的 Git 仓库托管服务，例如 Github、Gitee，（相当于使用别人的 Git 服务器）\n\n","link":"/posts/notes/git/remote"},{"title":"Git 储存(store)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\n有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状 态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为 过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是`git stash` 命令\n\n","link":"/posts/notes/git/store"},{"title":"Git 标签(tag)","tags":["Git"],"categories":["Notes","Git"],"author":"毛先生","excerpt":"\nGit 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会 使用这个功能来标记发布结点（v1.0 等等）。\n\n","link":"/posts/notes/git/tag"},{"title":"2023 - 八股文面经","tags":["JavaScript","Css"],"categories":["Notes","Interview"],"author":"毛先生","excerpt":"\n基于某站（[2023最新八股文前端面试题（css、js、h5c3、Vue、echarts、uniapp、webpack、git、hr）](https://www.bilibili.com/video/BV15z4y1a7MN/?spm_id_from=333.337.search-card.all.click&vd_source=6dd5b04535a73bd222fbca89d1967e60)）内容，根据个人修改的笔记。\n\n## CSS\n\n提问：说一下 CSS 的盒模型的具体构成内容。\n\n回答：盒模型（Box Model）包含 content、padding、margin 部分组成，通过设置 `box-sizing` 属性更改 content 中占比。\n\n---\n\n提问：CSS 选择器的优先级？\n\n回答：\n\nCSS 选择器有三大特性，继承、层叠、优先级\n\n优先级特点为不同选择器权重不同，分别为：标签、类/伪类/属性、全局选择器、行内样式、ID、`!important`\n\n层叠提现为通过一个选择的组合叠加权重，通常通过多个选择器组成，形成更高的权重：\n\n```css\ndiv.button {}\n```\n","link":"/posts/notes/interview/01_2023"},{"title":"CSS 编写规范","tags":["Css"],"categories":["Notes","Standard"],"author":"毛先生","excerpt":"\n关于 CSS 的标准。\n\n## 类命名\n\n类命名采用小写，中划线（ - ）分开关键字命名，英文单词尽量不要缩写。\n\n~~~css\n/* 符合 */\n.video-warp {}\n/* 不符合 */\n.video_warp {}\n.videoWarp {}\n.VIDEOWarp {}\n~~~\n\n","link":"/posts/notes/standard/css"},{"title":"JavaScript 编写规范","tags":["JavaScript"],"categories":["Notes","Standard"],"author":"毛先生","excerpt":"\n自以为是的 JavaScript 标准。\n\n## 变量/函数命名\n\n- 数据对应命名描述（命名统一）\n\n~~~ts\n// 列表类型命名(商品列表, 购物车列表, 表格列表等)\nconst goodList = [] // 对应子项 -> goodItem\nconst cartList = [] // 对应子项 -> cartItem\nconst tableList = [] // 对应子项 -> tableItem\n// 详情类型命名(店铺详情, 商品详情, 订单详情等)\nconst shopDetail = {}\nconst goodDetail = {}\nconst orderDetail = {}\n// 信息类型命名(用户信息, 页面信息, 财务信息等)\nconst userInfo = {}\nconst pageInfo = {}\nconst financeInfo = {}\n// 描述类型命名(当前项, 当前索引, 当前类型等)\nconst currentItem = {}\nconst currentIndex = {}\nconst currentType = {}\n// 配置类型命名(图像配置, 用户配置等)\nconst ghlOption = {}\nconst userOption = {}\n// 元素类型命名(DOM节点, Ref节点)\nconst htmlRef = document.querySelector('html')\nconst bodyRef = ref<HTMLBodyElement>()\n~~~\n\n","link":"/posts/notes/standard/javascript"},{"title":"前端面试题目（偏向于 Vue 方向）","tags":["topic"],"categories":["Notes","Standard"],"author":"毛先生","excerpt":"\n关于面试题目的记录，公司内部面试使用。偏技术向，主要考察面试者的基础技术能力。\n\n","link":"/posts/notes/standard/topic-vue"},{"title":"TypeScript 编写规范","tags":["TypeScript"],"categories":["Notes","Standard"],"author":"毛先生","excerpt":"\n自以为是的 TypeScript 标准。\n\n### 类型定义\n\n- 类型丢失率减少至百分之35%以下，减少使用any定义类型。\n- 尽量使用 TypeScript 的类型推测，减少多余类型的定义，除非是复合类型。\n\n~~~typescript\n// 正确\nconst count = 123\nconst count:number|string = 123\nmethods: {\n\tonClick(){/*...*/},\n\tonMove(){/*...*/},\n}\n// 不正确\nconst count:number = 123\nmethods: {\n\tonClick():any{/*...*/},\n\tonMove():any{/*...*/},\n}\n~~~\n\n","link":"/posts/notes/standard/typescript"},{"title":"365电吉他养成计划 - 前言","tags":["guitar","blog"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n总之，我又开始练琴了，感觉每次练琴间隔的周期总是拉的好长，总是有很多事情要考虑（借口），这次也按照往常一样，先不要给自己那么大压力把，买了本书，365 日电吉他手养成计划，很不错啊，每天都有计划，那么就从这个教材开始把！\n\n> 之后打算把练琴的曲子都录入到这个地方，也许会分多个栏目把，现在应该暂时还不需要。\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-1"},{"title":"365电吉他养成计划 - 第二周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n## 第二周（拨片）\n\n转眼间就第二周了！总体下来第一周难度不是很大，甚至连茧都没练出来，接下来会有的受苦的了_(:з」∠)_（肯定很疼）\n\n第二周是拨片弹奏动作练习，像一个帽子的是下拨，V 字是上拨，以下是关于书中对于交替拨弦的说明：\n\n根据节奏使用拨片交替进行下拨和上拨的技法，叫做“交替拨弦”。在一些乐句中，为了保持拨片的上下交替顺序不变，有时拨片会在上拨或下拨的时候进行 “空拨” （即做出拨弦的动作但不碰弦）使用这种技法有助于保持弹奏时节奏的稳定性和音色的颗粒感。\n \n> 感觉拨空的时候，总是感到莫名的慌张是为什么呢\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-2"},{"title":"365电吉他养成计划 - 第三周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n## 第二周（拨片）\n\n坚持第三周了，感觉慢慢找回以前的水平了，另外有事情干真的挺好，不会让自己闲着难受。\n\n这周是练习在琴弦上进行移动，是我目前比较弱的部分。\n\n> 书本 Tips：在全部琴弦和品格上流畅移动的练习，是每天开始练琴以前必须进行的热身动作（好的师傅）\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-3"},{"title":"365电吉他养成计划 - 第四周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n第四周了，大家过得怎么样，练琴是一个好漫长好漫长的过程，坚持下去真的挺不容易的，希望能继续下去，加油！\n\n在琴弦上横向移动的机械练习。\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-4"},{"title":"365电吉他养成计划 - 第五周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n这周的乐句都比较简单，但都很有用？现在我不太清楚，我只知道这是这周的练习都是一些常见的音阶。\n\n> 通常来说，吉他 solo 几乎都是使用某些音阶来编排的。听说这本书从大调音阶开始，会涉及弹奏各式各样的音阶，包括altered（变属音阶）、全音阶等等爵士乐常用的音阶。但不管弹哪种音阶，都应该先掌握基础的 C 大调音阶。“A、B、C·····” 这样的音名，也能在练习音阶的过程中得以强化记忆。\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-5"},{"title":"365电吉他养成计划 - 第六周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n\n击弦是指 “用指尖捶击琴弦来产生音” 的技巧。勾弦是指 “靠手指把弦一勾一放来产生音” 的技巧。无论是击弦还是勾弦，都是弹奏电吉他的必备技巧。即使不用拨片，仅靠击勾弦技巧也能很容易地实现速弹。另外，使用击勾弦技巧也能使弹奏的音色增加变化，从音乐的表现力这一点来看，也是非常重要的技巧。所以要以练出强健的手指头作为练习目标!\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-6"},{"title":"365电吉他养成计划 - 第七周","tags":["guitar","blog","daily"],"categories":["Music","Guitar","365电吉他养成计划"],"author":"毛先生","excerpt":"\n晚上好，现在快 1 点了，上周末因为要去海边表演，所以耽误了练琴的时间。啊，说是表演，但不是什么大不了的事情，况且我也就只会弹个两三曲（也只排练了这么点），其他基本都是键盘跟木吉他在旁边跟观众点歌玩，所以我实际上是去蹭饭的。\n\n最近报了个班，因为想继续跟他们组乐队，所以在恶补技术跟理论，起码要能保证做到看简谱自己编旋律跟一些简单的 solo 把，加油！\n\n这周的练习是大调音阶的七个把位，把位的意思就是从什么音开始，在键盘乐器中，C 大调音阶的音符都在白键上，任何人都能做到准确地弹奏“多米瑞”，但在吉他指板上是没有颜色之分的。为了能做到看到吉他指板，就能在脑中浮现出“多米瑞···”的位置，我们就需要进行音阶的相关练习。\n\n","link":"/posts/music/guitar/365%E6%97%A5%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/week-7"},{"title":"小林克己初级 - 第一章","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n小林克己我在 20 年就已经练完了，怎么说呢，弹的曲子细节处理的都比较随便，并且也没有录像录音，所以打算是想重新把所有曲子弹完，并争取做到跟原曲一样的细节处理。\n\n前面 10 几页基本都是讲一些吉他的基础知识跟基本的音阶，C、G、D、A、E、B、F、Bb、Eb、Ab、Db、Gb、F#\n\n第一章的内容是一些拨弦跟按弦的基本姿势，太基础了我们就跳过吧\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-1"},{"title":"小林克己初级 - 第十章（滑弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n滑弦这种技巧，就是在按着琴弦的情况下，在琴弦上滑动手指来改变音高，使同一根弦上的两个音连在一起的技巧。\n\n滑弦分为定向滑弦和无定向滑弦，本章节全部是指定向划弦。与无定向滑弦不同，滑弦是从起始音到结束音的音高都非常明确的技巧。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-10"},{"title":"小林克己初级 - 第十一章（无定向滑弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n无定向滑弦，也可以把他看做是定向滑弦的一种，无定向划弦的\n\n滑弦分为定向滑弦和无定向滑弦，本章节全部是指定向划弦。与无定向滑弦不同，滑弦是从起始音到结束音的音高都非常明确的技巧。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-11"},{"title":"小林克己初级 - 第十二章（制音）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n所谓制音，就是用左手或右手掌缘（小指一侧）轻微地触弦，巧妙地抑制声音音量的技巧。除了作为奏法使用之外，还兼有“消去不必要的声音”的作用。想要弹出干净的声音，必然要用到这种方法，因此也是很重要的技巧。在此，以“作为奏法的制音”为中心，讲解谱例和练习。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-12"},{"title":"小林克己初级 - 第二章（基础练习）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n第二章，是一些基础的练习，基础的练习可以跳过，有一小段应该还算挺有用，就是关于一些 C 大调音阶的练习。\n\nEX6 的练习曲是 C 大调（Cmajor scale）的练习曲，EX7 是 a（Anatural minor scale）小调的练习曲，EX8 与 EX6 仅把位不同，是另一个把位的 C 大调练习曲，这三个把位练习是吉他练习中最具效果的。学完之后，还可以按照这三个练习曲的指法，只需通过上移或下移品位，就可以在不同的位置上弹出其他调的练习曲。重要的是每个大小调都要练习，这三首练习曲变换把位和调性的关系如下表：\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-2"},{"title":"小林克己初级 - 第三章（和弦弹奏与扫弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n和弦是支撑起旋律的应该重要因素。在华丽的吉他 Solo 的背景里，同样需要和弦衬底。要了解和弦，就要通过左右手的练习来掌握和弦的奏法。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-3"},{"title":"小林克己初级 - 第四章（推弦姿势）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n推弦，就是把按着的琴弦上推或者下拉，通过增加弦的张力，来改变音程的技巧。这是吉他独有的技巧，更是摇滚吉他中不可或缺的色彩技巧。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-4"},{"title":"小林克己初级 - 第五章（各音程的推弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n推弦，就是改变音程的技巧。就是说，弹奏的重点在于，推弦是否能正确地改变音程。姿势虽说也很重要，但能够成功地表现出正确的音程才是推弦成功地一步。一般在品位之间变化音高，只能半音半音地改变，但通过推弦，则可以表现出更加微妙的音程变化。这样一来，要想掌握推弦技巧的话，就要学会控制音程的变化。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-5"},{"title":"小林克己初级 - 第六章（推弦释放）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n推弦释放，就是推弦的反过程。即把弦推上去再把弦释放回原位，这个过程的音一定要连贯。当然，在前面实际演奏Practice1~5时，虽然也有把推上去的弦放下来的动作，但那只是一个自然的动作，并不是现在所说的推弦释放这个技巧。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-6"},{"title":"小林克己初级 - 第七章（锤弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n所谓的锤弦，就是不用右手弹奏，纯粹是靠左手手指在指板上锤击琴弦而得到的音。正因为是用手锤击，所有被称为锤弦。\n\n通常锤弦时，为了不碰到其他弦，就必须弯起第一个关节。根据锤弦力度的大小不同，锤弦音量的大小和其中的细微差别也会有变化。刚开始练习时，应该尽可能地用力锤弦。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-7"},{"title":"小林克己初级 - 第八章（勾弦）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n所谓勾弦，就是左手手指快速地把弦一勾一放而产生音的技巧。第七章的锤弦，在奏法上，是用在上行音阶，而勾弦则相反，是用在下行音阶中。勾弦与锤弦一样，是为了得到和拨片弹奏不同的效果，让音乐的表现力更加丰富。\n\n只把手指从琴弦上抬起来，是不能弹出饱满的勾弦音的。当然，在某些必要的场合，也需要把手指抬起来，以产生轻微的勾弦音。但是，想要弹出响亮的勾弦音的话，手指必须先把琴弦按在纸板上，然后往下一根弦的方向勾弦。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-8"},{"title":"小林克己初级 - 第八章（震音）","tags":["guitar","blog"],"categories":["Music","Guitar","小林克己初级"],"author":"毛先生","excerpt":"\n震音是指两个或两个以上的音迅速交替重复。在吉他上就是快速连续地、交替使用锤弦和勾弦两种技巧，以弹出连贯的装饰音。也就是说，诸如 H→P→H→P、P→H→P→P 这两种简单的交替勾弦锤弦，就是震音的初步。使用这种技巧，只用左手就可以在两个音之间回旋。\n\n","link":"/posts/music/guitar/%E5%B0%8F%E6%9E%97%E5%85%8B%E5%B7%B1-%E5%88%9D%E7%BA%A7/chapter-9"},{"title":"BitcoinJS - 比特币应用开发","tags":["Bitcoin"],"categories":["Notes","BlockChain","Bitcoin"],"author":"毛先生","excerpt":"\n用于 node.js 和浏览器的 javascript 比特币工具库。用 TypeScript 编写。\n\n\n## ECPair\n\n它由两部分组成，生成助记符，并将其转换为二进制种子。这个种子稍后可以使用 BIP-0032 或类似的方法来生成确定性钱包。\n\nECPair 是指通过椭圆曲线算法生成钥匙对，简单点来说，它可以生成一个随机的密匙对：\n\n```ts\nimport ECPairFactory from 'ecpair'\nimport * as bitcoin from 'bitcoinjs-lib'\n\nconst ECPair = ECPairFactory(ecc)\nconst keyPair = ECPair.makeRandom()\nconst wif = keyPair.toWIF()\nconst privateKey = keyPair.privateKey.toString('hex')\nconst publicKey = keyPair.publicKey.toString('hex')\n// p2pkh 用于获取 address，和钱包其他信息\nconst address = bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey }).address\n```\n\n这里出现了几个陌生的概念， `WIF`、`privateKey`、`publicKey`，这些都是些什么？\n\n","link":"/posts/notes/blockchain/bitcoin/bitcoinjs"},{"title":"加密数字货币 - 比特币（Bitcoin）","tags":["Bitcoin"],"categories":["Notes","BlockChain","Bitcoin"],"author":"毛先生","excerpt":"\n比特币（Bitcoin）的概念最初由中本聪在2008年11月1日提出，并于2009年1月3日正式诞生，根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的数字货币。比特币的交易记录公开透明，而点对点的传输意味着一个去中心化的支付系统。\n\n","link":"/posts/notes/blockchain/bitcoin"},{"title":"BitcoinJS - 比特币全服务钱包开发","tags":["Bitcoin"],"categories":["Notes","BlockChain","Bitcoin"],"author":"毛先生","excerpt":"\n比特币钱包涉及钱包程序或钱包文件，钱包程序可以创建公钥来收取比特币，同时使用相应的私钥来划掉这些比特币，钱包文件保存了私钥，以及为钱包程序保存了一些交易相关的信息。\n\n- https://wenku.baidu.com/view/ea8d1377834d2b160b4e767f5acfa1c7aa00829f.html\n\n收取，花掉比特币是钱包程序最基本的功能，但一个特定的钱包不必包含着两个功能，两个钱包程序能一起协调工作，一个负责分发公钥，用于来收取比特币，另外一个程序负责签名交易，来花掉这些比特币。\n\n## 全服务钱包\n\n最简单的钱包就是包含三个功能，它生成私钥，然后基于它生成相应的私钥，在需要时，分发这些公钥，监控在执行公钥的输出，创建，签名交易（用于花掉输出），广播签名后的交易。\n\n全服务钱包的主要缺点是它们在连接互联网的设备上储存私钥，这种设备被入侵是常见的事情，因特网连接使得容易将私钥从被感染的设备发送给攻击者。\n\n为了防盗，许多钱包程序为用户提供了可选项加密包含私钥的钱包文件。当私钥不被使用时，它可以提供保护，但是不能防范捕获的攻击从内存中读取解密方法。\n\n","link":"/posts/notes/blockchain/bitcoin/wallet"},{"title":"Solidity 智能合约语言","tags":["Solidity"],"categories":["Notes","BlockChain","Solidity"],"author":"毛先生","excerpt":"\n智能合约是运行在链上的程序，合约开发者可以通过智能合约实现与链上资产/数据进行交互，用户可以通过自己的链上账户来调用合约，访问资产与数据。因为区块链保留区块历史记录的链式结构、去中心化、不可篡改等特征，智能合约相比传统应用来说能更公正、透明。\n\n然而，因为智能合约需要与链进行交互，部署、数据写入等操作都会消耗一定费用，数据存储与变更成本也比较高，因此在设计合约时需要着重考虑资源的消耗。此外，常规智能合约一经部署就无法进行修改，因此，合约设计时也需要多考虑其安全性、可升级性与拓展性。\n\nSolidity 是一门面向合约的、为实现智能合约而创建的高级编程语言，在 EVM 虚拟机上运行，语法整体类似于 Javascript，是目前最流行的智能合约语言，也是入门区块链与 Web3 所必须掌握的语言。针对上述的一些合约编写的问题，Solidity 也都有相对完善的解决方案支持。\n\n","link":"/posts/notes/blockchain/solidity"},{"title":"AngularJS 基本应用","tags":["angularjs"],"categories":["Notes","Client","angularjs"],"author":"毛先生","excerpt":"\n## ng-app（指令）\n\n告诉angular核心它管理当前标签所包含的整个区域,并且会自动创建$rootScope根作用域对象\n\n~~~html\n<body ng-app>\n</body>\n~~~\n\n## ng-model（指令）\n\n将当前输入框的值与谁关联(属性名:属性值), 并作为当前作用域对象($rootScope)的属性\n通常表示一个完整的执行单位，一段完整的js可执行的代码，有的语句也可以用表达式来执行，叫做表达式语句。\n\n","link":"/posts/notes/client/angularjs/baisc"},{"title":"AngularJS 常用指令","tags":["angularjs"],"categories":["Notes","Client","angularjs"],"author":"毛先生","excerpt":"\n`Angular` 为 `HTML` 页面扩展的自定义标签属性或标签 与`Angular` 的作用域对象 `(scope)` 交互,扩展页面的动态表现力。\n\n- ng-app: 指定模块名，angular管理的区域\n- ng-model： 双向绑定，输入相关标签\n- ng-init： 初始化数据\n- ng-click： 调用作用域对象的方法（点击时）\n- ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）\n- ng-bind： 解决使用`{{}}`显示数据闪屏（在很短时间内显示`{{}}`）\n- ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域\n  - $index, $first, $last, $middle, $odd, $even\n- ng-show: 布尔类型， 如果为true才显示\n- ng-hide: 布尔类型， 如果为true就隐藏\n\n","link":"/posts/notes/client/angularjs/command"},{"title":"AngularJS 控制器","tags":["angularjs"],"categories":["Notes","Client","angularjs"],"author":"毛先生","excerpt":"## 函数控制器 （v1.2）\n\n用来控制 AngularJS 应用数据的 实例对象\n`ng-controller` 指定控制器构造函数, `Angular`会自动`new`此函数创建控制器对象，同时`Angular`还有创建一个新的域对象`$scope`, 它是`$rootScope`的子对象。\n\n> 形参必须是特定的名称, 否则 `AngularJS` 无法注入抛异常\n\n","link":"/posts/notes/client/angularjs/controller"},{"title":"AngularJS 前端框架开发","tags":["angularjs"],"categories":["Notes","Client","angular"],"author":"毛先生","excerpt":"\nGoogle开源的前端结构化框架，动态展示页面数据, 并与用户进行交互，它们具有以下特点：\n\n- 双向数据绑定\n- 声明式依赖注入\n- 解耦应用逻辑, 数据模型和视图\n- 完善的页面指令\n- 定制表单验证\n- Ajax 封装\n\n","link":"/posts/notes/client/angularjs"},{"title":"CSS 基本概念","tags":["Css"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\n层叠样式表 (`Cascading Style Sheets`，缩写为 `CSS`），是一种 [样式表](https://developer.mozilla.org/zh-CN/docs/Web/API/StyleSheet) 语言，用来描述 [HTML](https://developer.mozilla.org/zh-CN/docs/Web/HTML) 或 [XML](https://developer.mozilla.org/zh-CN/docs/Web/XML/XML_Introduction)（包括如 [SVG](https://developer.mozilla.org/zh-CN/docs/Web/SVG)、[MathML](https://developer.mozilla.org/zh-CN/docs/Web/MathML)、[XHTML](https://developer.mozilla.org/zh-CN/docs/Glossary/XHTML) 之类的 `XML` 分支语言）文档的呈现。[CSS](https://w3.org/Style/CSS/#specs) 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。\n\n`CSS` 是开放网络的核心语言之一，由 W3C 规范 实现跨浏览器的标准化。`CSS` 节省了大量的工作。 样式可以通过定义保存在外部 `.css` 文件中，同时控制多个网页的布局，这意味着开发者不必经历在所有网页上编辑布局的麻烦。`CSS` 被分为不同等级：`CSS1` 现已废弃， `CSS2.1` 是推荐标准， `CSS3` 分成多个小模块且正在标准化中。\n\n","link":"/posts/notes/client/css/basic"},{"title":"CSS3 应用","tags":["Css"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\nCSS3是[CSS](https://baike.baidu.com/item/CSS/5457)（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。\nCSS演进的一个主要变化就是W3C决定将CSS3分成一系列模块。浏览器厂商按CSS节奏快速创新，因此通过采用模块方法，CSS3规范里的元素能以不同速度向前发展，因为不同的浏览器厂商只支持给定特性。但不同浏览器在不同时间支持不同特性，这也让跨浏览器开发变得复杂。\n\n","link":"/posts/notes/client/css/css3"},{"title":"Flex Layout","tags":["Css"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\n\nflex-box 布局（也叫Flex布局，弹性盒子布局）模块（ W3C 候选推荐，截止到2017年10月）旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。\n\nFlex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。\n\n最重要的是，flex-box 布局与方向无关，不同于常规布局（基于垂直的块（block）和基于水平的内联（inline））。 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面）。\n\n","link":"/posts/notes/client/css/flex"},{"title":"Grid Layout","tags":["Css"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\n`Grid` 布局即网格布局，是一种新的 `css` 模型，一般是将一个页面划分成几个主要的区域，定义这些区域的大小、位置和层次等关系，是目前唯一一种 `css` 二维布局。\n\n`Grid` 布局和 `flex` 布局是有实质性的区别的，`flex` 是一维布局，只能处理一个维度上的布局，一行或者是一列。但是 `Grid` 布局是二维布局 ，将容器划分成了“行”和“列”，产生了一个个的网格，可以将网格元素放在行和列相关的位置上，从而达到了布局的目的。\n\n","link":"/posts/notes/client/css/grid"},{"title":"CSS 布局","tags":["Css","layout"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\nCSS 布局易于设计。我们可以使用 CSS 布局来设计我们的网页，例如主页，与我们联系，关于我们等。\n\n基本上有三种设计网页布局的方法：\n\nHTML Div + CSS 布局：现在已广泛使用。\n\nHTML表格：速度较慢，较不受欢迎。\n\nHTML框架集：现已弃用。\n\nCSS布局可以包含页眉，页脚，左窗格，右窗格和正文部分。\n\n","link":"/posts/notes/client/css/layout"},{"title":"Less 样式预处理语言","tags":["Css","less"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\nLess 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量、Mixin、函数等特性。Less 可以运行在 Node 或浏览器端。\n\n","link":"/posts/notes/client/css/less"},{"title":"页面渲染机制","tags":["Css"],"categories":["Notes","Client","Css"],"author":"毛先生","excerpt":"\n在页面的生命周期中，**网页生成的时候，初始化至少渲染一次。在用户访问的过程中，则会不断的触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，在现代前端开发中，动效和动画效果的性能逐渐引起人们的重视，如何避免付出高额的性能代价，成为了我们前端工程师应该考虑的因素。\n\n","link":"/posts/notes/client/css/render"},{"title":"ECMAScript 6","tags":["ECMAScript","ES6"],"categories":["Notes","Client","ECMAScript"],"author":"毛先生","excerpt":"\nECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n","link":"/posts/notes/client/ecmascript/ECMAScript-6"},{"title":"ECMAScript 7","tags":["ECMAScript","ES6"],"categories":["Notes","Client","ECMAScript"],"author":"毛先生","excerpt":"\nECMAScript 7又以JavaScript 2016而被熟知，是正在快速开发的新一代JavaScript编程语言标准。尽管该标准需要等到明年才发布，但是诸多浏览器已经做好了准备。同往常一样，Chrome和Firefox率先做出改变，而今天召开的微软开发者网络会议上，负责HTML5和开源网页标准的主要项目经理 David Catuhe 也宣布Edge浏览器开始部署ECMAScript 7功能。\n\n","link":"/posts/notes/client/ecmascript/ECMAScript-7"},{"title":"ECMAScript 8~11","tags":["ECMAScript","ES6"],"categories":["Notes","Client","ECMAScript"],"author":"毛先生","excerpt":"\nES8 是 ECMA协会在 2017 年 6 月发行的一个版本，因为是ECMAScript的第八个版本，所以也称为ES8，之后每个更新的内容的在此。\n\n","link":"/posts/notes/client/ecmascript/ECMAScript-8-11"},{"title":"ECMAScript 标准化语言","tags":["ECMAScript"],"categories":["Notes","Client","ECMAScript"],"author":"毛先生","excerpt":"\nECMAScript是一种由 Ecma 国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。\n\n","link":"/posts/notes/client/ecmascript"},{"title":"Electron 主应用方法与事件","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\n\nElectron 主进程是 Electron 应用程序的核心组成部分，它负责管理应用程序的生命周期、处理系统级别的操作和提供与操作系统和渲染进程的通信。主进程在 Electron 应用程序启动时创建，并且只有一个实例。\n\n主进程的代码通常位于应用程序的主文件中，例如 main.js。它使用 Node.js 运行，并可以访问底层的操作系统资源和 Electron API。\n\n下面的这个例子将会展示如何在最后一个窗口被关闭时退出应用：\n\n```ts\nconst { app } = require('electron')\napp.on('window-all-closed', () => app.quit())\n```\n\n","link":"/posts/notes/client/electron/app"},{"title":"Electron 窗口方法与事件","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nBrowserWindow 是 Electron 中用于创建和控制应用程序窗口的模块。每个 BrowserWindow 实例都代表一个独立的窗口，可以显示 Web 内容，并提供了许多配置选项和功能来满足应用程序的需求。\n\n","link":"/posts/notes/client/electron/browser"},{"title":"Electron 系统剪切板","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 提供了与剪贴板（clipboard）交互的功能，使开发者能够在应用程序中读取和写入剪贴板的内容。剪贴板是操作系统提供的一种机制，用于在应用程序之间传输数据，例如文本、图像或文件路径等。\n\n## 读取剪贴板内容\n\n通过调用 `clipboard.readText()` 方法，开发者可以读取剪贴板中的文本内容。\n\n","link":"/posts/notes/client/electron/clipboard"},{"title":"Electron 快捷键与系统快捷键","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 提供了一种简单而灵活的方式来定义和处理快捷键。通过 Electron，开发人员可以为应用程序添加自定义的全局快捷键，以触发特定的操作或功能。\n\nElectron 的快捷键分为两种，一种是程序自定义的快捷键，另外一种是系统快捷键：\n\n- **快捷键**：定义键盘快捷键。\n- **系统快捷键**：在应用程序没有键盘焦点时，监听键盘事件。\n\n快捷键可以包含多个功能键和一个键码的字符串，由符号 + 结合，用来定义你应用中的键盘快捷键。\n\n例如：\n\n- `CommandOrControl+A`\n- `CommandOrControl+Shift+Z`\n\n通过调用 `globalShortcut.register()` 方法，可以注册一个特定的快捷键和相应的回调函数。当用户按下注册的快捷键时，回调函数将被触发，从而执行相应的操作。\n\n","link":"/posts/notes/client/electron/command"},{"title":"Electron 原生对话框","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 提供了一个强大的模块，称为 dialog，用于在应用程序中显示对话框（dialog）。对话框是一种常见的用户界面元素，用于与用户进行交互，例如选择文件、保存文件、显示消息等。\n\n这些对话框提供了一种简单而方便的方式，使开发人员能够与用户进行交互，并在桌面应用程序中提供常见的操作和反馈机制。使用 Electron 的 dialog 模块，开发人员可以轻松地创建这些对话框，并根据应用程序的需要进行自定义。\n\n","link":"/posts/notes/client/electron/dialog"},{"title":"Electron 桌面开发应用","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\n\n[Electron](https://www.electronjs.org/) 是一个开源的框架，用于构建跨平台的桌面应用程序。它由GitHub开发，并且被许多知名的应用程序使用，如 [Visual Studio Code](https://code.visualstudio.com/)、[Slack](https://slack.com/intl) 和 [Discord](https://discord.com/) 等。\n\nElectron 最初是为了开发 GitHub 的桌面客户端而创建的，它的前身是 Atom Shell。它的设计目标是允许开发者使用 Web 技术，如 HTML、CSS 和 JavaScript 来构建桌面应用程序，而不需要了解底层的操作系统的特定细节。\n\n以下是 Electron 的一些关键特点和优势：\n\n- 跨平台：Electron 可以在多个操作系统上运行，包括 Windows、macOS 和 Linux。这意味着开发者可以使用相同的代码库来构建适用于不同平台的应用程序，从而提高开发效率和代码重用性。\n\n- 基于Web技术：开发者可以使用熟悉的Web技术来构建应用程序界面，包括 HTML、CSS 和 JavaScript。这使得Web开发者可以迅速上手并开始构建桌面应用程序，而无需学习额外的桌面开发技术。\n\n- 强大的生态系统：Electron 拥有庞大的生态系统，包括许多第三方库和插件，可以帮助开发者实现各种功能和扩展应用程序的能力。开发者可以从已有的库中选择适合自己需求的工具，加速开发过程。\n\n- 自定义能力：Electron 提供了灵活的自定义能力，开发者可以根据自己的需求定制应用程序的外观和行为。这意味着开发者可以实现与传统桌面应用程序相似的用户体验，同时通过Web技术带来更多的创新和交互方式。\n\n","link":"/posts/notes/client/electron"},{"title":"Electron 菜单定制化","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\n在 Electron 中，Menu（菜单）是一种用于创建应用程序菜单栏和上下文菜单的重要组件。它允许开发人员定义应用程序的菜单结构，并与相应的操作或功能关联起来。\n\n菜单可以包含多个菜单项（MenuItem），每个菜单项可以包含子菜单（SubMenu），形成多级菜单结构。\n\n","link":"/posts/notes/client/electron/menu"},{"title":"Electron 原生图片模块","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 的 nativeImage 模块是一个用于处理图像的功能强大的模块。它允许你在 Electron 应用程序中创建、操作和转换图像。\n\nnativeImage 模块提供了创建图像对象的方法，这些图像对象可以从文件系统中的文件、Buffer 对象或原生操作系统剪贴板中的图像数据中加载。还可以使用 nativeImage 实例的方法来处理和转换这些图像对象。\n\n","link":"/posts/notes/client/electron/native-image"},{"title":"Electron 主线程与渲染线程通信","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 是一个用于构建跨平台桌面应用程序的开源框架。它由主进程和渲染进程组成。\n\n主进程是 Electron 应用程序的入口点，负责管理应用程序的生命周期和系统级的操作，如窗口管理、文件系统访问等。\n\n渲染进程是负责显示用户界面的组件，使用 Web 技术构建界面，如 HTML、CSS 和 JavaScript。每个渲染进程对应一个应用程序窗口，可以通过 IPC 与主进程进行通信。\n\n![](https://pic.imgdb.cn/item/656f0bd5c458853aefd8c13e.png)\n\n主进程使用 BrowserWindow 创建实例，主进程销毁后，对应的渲染进程回被终止。主进程与渲染进程通过 IPC 方式（事件驱动）进行通信。\n\n","link":"/posts/notes/client/electron/renderer"},{"title":"Electron 系统托盘","tags":["Electron"],"categories":["Notes","Client","Electron"],"author":"毛先生","excerpt":"\nElectron 的 tray 是一个用于创建系统托盘图标的功能。它允许开发者在操作系统的任务栏或菜单栏中添加一个小图标，用于快速访问应用程序的某些功能或显示通知。\n\n\n通过调用 new Tray(path) 方法，开发者可以在应用程序中创建一个托盘图标，并指定图标的路径：\n\n","link":"/posts/notes/client/electron/tray"},{"title":"ESlint 常用规则","tags":["ESlint"],"categories":["Notes","Client","ESlint"],"author":"毛先生","excerpt":"\n`object-shorthand`\n**设置该规则，表示对象属性要简写。**\n\n~~~js\nvar foo = { x } // 会报错\nvar bar = { a() {} } // 会报错\nvar foo = { x } // 不会报错\nvar bar = { a() {} } // 不会报错\n~~~\n\n`prefer-arrow-callback`\n**要求回调函数使用箭头函数**\n\n~~~javascript\nfunction bar() {} \t\t\t\t// 不是回调函数，不会报错\nsetTimeout(function(){}, 1000)  // 报错\nsetTimeout(() => {}, 1000)\t\t// 不报错\n// setTimeout 的第一个参数就是回调函数，不用箭头函数会报错\n~~~\n\n`no-trailing-spaces`\n**禁止行尾空格**\n\n`no-shadow`\n**禁止变量声明与外层作用域的变量同名**\n\n~~~javascript\nfunction sum (num) {\n var num = 2;\n// 报错，因为 num 变量作为参数已经申明过了\n}\n~~~\n","link":"/posts/notes/client/eslint/common"},{"title":"Eslint 代码检测工具","tags":["ESlint"],"categories":["Notes","Client","ESlint"],"author":"毛先生","excerpt":"\n`ESLint` 是一个**开源的 JavaScript 代码检查工具**，由 `Nicholas C. Zakas` 于 2013 年 6 月 创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体 的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。\n\nJavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为 了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 `ESLint` 这样的可以**让程序员在编码的过程中发现问题**而不是在执行的过程中。 ESLint 的**初衷是为了让程序员可以创建自己的检测规则**。\n\nESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖 于同样的模式。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中 **自定义规则**。 `ESLint` 使用 `Node.js` 编写，这样既可以有一个快速的运行环境的同时也便于安装。\n\n","link":"/posts/notes/client/eslint"},{"title":"Gsap 上下文系统","tags":["Gsap"],"categories":["Notes","Client","Gsap"],"author":"毛先生","excerpt":"\n`gsap.context()` 可以收集在提供的函数内部创建的所有 GSAP 动画和 ScrollTrigger，从而使用 `revert()` 或 `kill()` 来统一处理状态。无需跟踪一堆变量、数组等，这在一些响应式框架中通过将元素恢复（清理）到原始状态特别有用。\n\n","link":"/posts/notes/client/gsap/context"},{"title":"Gsap Web 动画框架","tags":["Gsap"],"categories":["Notes","Client","Gsap"],"author":"毛先生","excerpt":"\nGreenSock动画平台（GSAP）可以对 JavaScript 可以操作的所有内容进行动画处理（CSS 属性，SVG，React，画布，通用对象等），同时解决了不同浏览器上存在的兼容性问题，而且速度极快（比jQuery 快20倍）。大约有 1000 万个站点和许多主要品牌都使用 GSAP。\n\n官网：https://greensock.com/\n\n","link":"/posts/notes/client/gsap"},{"title":"Gsap 核心插件 - CSS","tags":["Gsap"],"categories":["Notes","Client","Gsap"],"author":"毛先生","excerpt":"\n在 CSSPlugin 的帮助下，GSAP 可以为几乎任何与 CSS 相关的 DOM 元素属性设置动画，包括像宽度、高度、边距、填充、顶部、左侧等明显的东西，以及更多有趣的东西，比如变换（旋转、缩放 X、缩放 Y 、skewX、skewY、x、y、rotationX 和 rotationY）、颜色、不透明度等等。\n\n","link":"/posts/notes/client/gsap/plugin-css"},{"title":"HTML 超文本标记语言","tags":["HTML"],"categories":["Notes","Client","HTML"],"author":"毛先生","excerpt":"\n[HTML](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element)（超文本标记语言——HyperText Markup Language）是构成 Web 世界的一砖一瓦。它定义了网页内容的含义和结构。除 HTML 以外的其它技术则通常用来描述一个网页的表现与展示效果（如 [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS)），或功能与行为（如 [JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)）。\n\n“超文本”（hypertext）是指连接单个网站内或多个网站间的网页的链接。链接是网络的一个基本方面。只要将内容上传到互联网，并将其与他人创建的页面相链接，你就成为了万维网的积极参与者。\n\nHTML 使用“标记”（markup）来注明文本、图片和其他内容，以便于在 Web 浏览器中显示。HTML 标记包含一些特殊“元素”如 [`<head>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head)，\n[`<title>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/title)，\n[`<body>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body)，\n[`<header>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header)，\n[`<footer>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer)，\n[`<article>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article)，\n[`<section>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section)，\n[`<p>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p)，\n[`<div>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div)，\n[`<span>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span)，\n[`<img>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img)，\n[`<aside>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/aside)，\n[`<audio>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio)，\n[`<canvas>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas)，\n[`<datalist>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/datalist)，\n[`<details>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/details)，\n[`<embed>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed)，\n[`<nav>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/nav)，\n[`<output>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/output)，\n[`<progress>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/progress)，\n[`<video>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video)\n 等等等等。\n\n","link":"/posts/notes/client/html/basic"},{"title":"HTML5 超文本语言规范","tags":["HTML"],"categories":["Notes","Client","HTML"],"author":"毛先生","excerpt":"\nHTML5是构建Web内容的一种语言描述方式。HTML5是互联网的下一代标准，是构建以及呈现互联网内容的一种语言方式．被认为是互联网的核心技术之一。HTML产生于1990年，1997年HTML4成为互联网标准，并广泛应用于互联网应用的开发。\n\nHTML5是Web中核心语言HTML的规范，用户使用任何手段进行网页浏览时看到的内容原本都是HTML格式的，在浏览器中通过一些技术处理将其转换成为了可识别的信息。HTML5在从前HTML4.01的基础上进行了一定的改进，虽然技术人员在开发过程中可能不会将这些新技术投入应用，但是对于该种技术的新特性，网站开发技术人员是必须要有所了解的。\n\n","link":"/posts/notes/client/html/html5"},{"title":"JavaScript 基础应用","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nJavaScript（JS）是一种具有[函数优先](https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function)特性的轻量级、解释型或者说[即时编译型](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF)的编程语言。虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多[非浏览器环境](https://en.wikipedia.org/wiki/JavaScript#Other_usage)中，例如 [Node.js](https://developer.mozilla.org/zh-CN/docs/Glossary/Node.js)、[Apache CouchDB](https://couchdb.apache.org/)、[Adobe Acrobat](https://opensource.adobe.com/dc-acrobat-sdk-docs/acrobatsdk/) 等。进一步说，JavaScript 是一种[基于原型](https://developer.mozilla.org/zh-CN/docs/Glossary/Prototype-based_programming)、多范式、单线程的动态语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。\n\n不要将 JavaScript 与 [Java 编程语言](https://en.wikipedia.org/wiki/Java_(programming_language))混淆。虽然“Java”和“JavaScript”都是 Oracle 公司在美国和其他国家注册（或未注册）的商标，但是这两门语言在语法、语义与用途方面有相当大的不同。\n\n","link":"/posts/notes/client/javascript/baisc"},{"title":"JavaScript BOM","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\n浏览器对象模型(BOM)可以使我们通过JS来操作浏览器，以及获取浏览器信息。通常BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用。\n\n","link":"/posts/notes/client/javascript/bom"},{"title":"JavaScript Canvas Animation","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\n要实现 canvas 中的动画，本质上是通过储存|计算|处理，不断的绘制画面帧，从而实现动画的流程运行。\n\n由此可见，动画构造器应具有以下特点：\n\n- 数据容器(所有绘制体)\n- 定时注入(单个绘制体)\n- 数据变化(绘制体信息产生的变化|状态)\n- 数据绘制(将数据作用于画布)\n\n实际运作流程：不断注入 -> 循环变化 -> 循环绘制\n\n","link":"/posts/notes/client/javascript/canvas-animation"},{"title":"JavaScript Canvas","tags":["JavaScript","HTML","canvas"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nCanvas API（画布）是在HTML5中新增的标签用于在网页实时生成图像，并且可以操作图像内容，基本上它是一个可以用JavaScript操作的位图（bitmap）。\nCanvas 对象表示一个 HTML 画布元素 - `<canvas>`。它没有自己的行为，但是定义了一个 API 支持脚本化客户端绘图操作。\n\n","link":"/posts/notes/client/javascript/canvas"},{"title":"JavaScript 概念","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\n## 基本(值)类型\n\n- `Number` ----- 任意数值 -------- `typeof == Number `\n- `String` ----- 任意字符串 ------ `typeof == String `\n- `Boolean` ---- true/false ----- `typeof == Boolean`\n- `undefined` -- undefined -----  `typeof == undefined`\n- `null` ------- null ----------  `typeof == Object`\n\n## 对象(引用)类型\n\n- `Object` ----- `typeof/instanceof == Object/true`\n- `Array` ------ `instanceof == true`\n- `Function` --- `typeof == function`\n\n## 数据|变量|内存\n\n**数据**：在内存中可读的, 可传递的保存了特定信息的'东东'\n- 一切皆数据, 函数也是数据\n- 在内存中的所有操作的目标 --> 数据\n\n**变量**：在程序运行过程中它的值是允许改变的量\n- 一个变量对应一块小内存, 它的值保存在此内存中  \n\n**内存**：内存条通电后产生的存储空间(临时的)\n- 一块内存包含内部存储的数据，地址值数据\n\n","link":"/posts/notes/client/javascript/concept"},{"title":"JavaScript 设计模式","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nJavaScript 是多模式混合的代码编程，面向对象的，以原型为基础的，拥有动态数据类型，一方面将函数看做是一等公民，允许函数是编程的风格，另一方面，不排斥传统的面向对象方式进行开发。\n\n","link":"/posts/notes/client/javascript/design"},{"title":"JavaScript DOM","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nJavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象， DOM 则描述了处理网页内容的方法和接口；\n\n<!-- - BOM 描述了与浏览器进行交互的方法和接口。 -->\n\n","link":"/posts/notes/client/javascript/dom"},{"title":"JavasScript drag","tags":["JavaScript","HTML5"],"categories":["Notes","Client","HTML"],"author":"毛先生","excerpt":"\n拖拽功能的实现主要依靠3个事件，分别是 onousedown 鼠标按下、onmousemove 鼠标移动和 onmouseup 鼠标抬起。\n并且它们具体是按照这样的一个顺序执行的。\n\n- event.clientX 和 event.clientY 分别是鼠标当前的横坐标和纵坐标\n- offsetX 和 offsetY 分别表示元素的初始横坐标和纵坐标，移动的过程改变的是绝对定位下的left和top值。\n\n","link":"/posts/notes/client/javascript/drag"},{"title":"JavaScript 类型原型与方法","tags":["JavaScript"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nJavaScript 每个类型类提供了大量可用方法，在程序开发中是必须掌握的技巧。\n\n","link":"/posts/notes/client/javascript/function"},{"title":"JavaScript HTML5","tags":["JavaScript","HTML5"],"categories":["Notes","Client","JavaScript"],"author":"毛先生","excerpt":"\nHTML5 实际上并没有多少与 HTML 有关，它其实就是 JavaScript。HTML 本身有什么变化?不过一些新标签而已， 况且哪个新标签都不难理解。HTML5的威力在于让你能用JavaScript来创建这些标签。假如没有后台代码通过 Canvas 来创建动画、游戏，或者 通过它来实现一些数据的可视化，这个标签也没有大用处。从浏览器开始支持 Canvas 开始，我已经看到了A steroids 的上百个实现，那都是开发人员为熟悉这个新特性所做的练习。有的比较粗糙一些，而有的则极其精美。这些完全都要归功于 JavaScript。\n\n一个好的程序人员不得不承认 JavaScript 是 html5 实现的有力后盾，简单说，在现在的互联网网站建设开发行业中，大家必须要了解这些知识，才能让我们的网站建设路走的一马平川。\n\n","link":"/posts/notes/client/javascript/html5"},{"title":"Windows 关于 C++ 集成的 node 插件配置","tags":["Options"],"categories":["Notes","Client","Options"],"author":"毛先生","excerpt":"\n在一些特殊的开发场景上，会用到 node-gyp，它需要 C++ 集成的工具和 python3，遇到了挺多坑点，整理一下自己踩过的坑，和具体配置的流程。\n\nnode-gyp 是一个可以编译 node 插件的工具，在使用 node-gyp 前需要安装 python 环境和 C++ 环境。\n\n","link":"/posts/notes/client/options"},{"title":"Babel AST 语法编译器","tags":["Babel"],"categories":["Notes","Client","Other"],"author":"毛先生","excerpt":"\n谈及 Babel,必然离不开 AST。有关 AST 这个知识点其实是很重要的，但由于涉及到代码编译阶段，大多情况都是由各个框架内置相关处理，所以作为开发(使用)者本身，往往会忽视这个过程。\n\n","link":"/posts/notes/client/other/babel-ast"},{"title":"Flutter 移动端应用开发","tags":["Flutter"],"categories":["Notes","Client","Other"],"author":"毛先生","excerpt":"\nFlutter 是谷歌的移动 UI 框架，可以快速在 IOS 和 Android 上构建高质量的原生用户界面。 Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。\n\n- **跨平台**：现在 Flutter 至少可以跨 4 种平台，甚至支持嵌入式开发。我们常用的有 Linux、Android、IOS，甚至可以在谷歌最新的操作系统上 Fuchsia 进行运行,经过第三方扩展，甚至可以跑在 MacOS 和 Windows 上，到目前为止，Flutter 算是支持平台最多的框架了，良好的跨平台性，直接带来的好处就是减少开发成本。\n- **原生用户界面**：它是原生的，让我们的体验更好，性能更好。用官方的话讲就是平滑而自然的滑动效果和平台感知，为您的用户带来全新的体验。\n\n","link":"/posts/notes/client/other/flutter"},{"title":"socked.io 实时应用开发","tags":["Flutter"],"categories":["Notes","Client","Other"],"author":"毛先生","excerpt":"\n由于写原生的 WebSocket 在处理低版本浏览器的兼容性上的困难，所以一般在写实时交互的这种项目时一般会利用到 `socket.io`。`socket.io` 并不仅仅是 `WebSocket`，还包含着 AJAX long polling，AJAX multipart streaming，JSONP Polling 等。`socket.io` 可以看做是基于 `engine.io` 的二次开发。通过 `emit` 和 `on` 可以轻松地实现服务器与客户端之间的双向通信，`emit`来发布事件，`on`来订阅事件。\n\n","link":"/posts/notes/client/other/socket.io"},{"title":"Typescript 版本升级后，AST 工具注释异常","tags":["Typescript"],"categories":["Notes","Client","Other"],"author":"毛先生","excerpt":"\n起因是某项目使用了 Typescript 自带的 Compiler API 去生成对应的代码，在 `typescript@4.6.4` > `typescript@4.9.5` 升级时出现 `createInterfaceDeclaration` 参数异常（Invalid arguments）的情况。\n\n","link":"/posts/notes/client/other/typescript-ast-error"},{"title":"VSCode Plugin 开发","tags":["VSCode"],"categories":["Notes","Client","Other"],"author":"毛先生","excerpt":"\nVSCode 是微软出的一款轻量级代码编辑器，免费而且功能强大，以功能强大、提示友好、不错的性能和颜值俘获了大量开发者的青睐，对 JavaScript 和 NodeJS 的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet 插件等。\n\n再强大的 IDE 那也不可能面面俱到什么功能都塞进去，那样只会导致 IDE 本身太臃肿。所以 VSCode 的很多强大功能都是基于插件实现的，IDE只提供一个最基本的框子和最基本功能，由插件来丰富和扩展它的功能。\n\n因为 VSCode 本身都是用浏览器实现的，所以其插件不用说肯定也是基于 `HTML+JS` 等前端技术实现，从形式上看就是一个类似于 npm 包的 `vsix` 文件，只不过按照一些特殊规范来实现一些特殊功能，所以 VSCode 插件开发难度不大，甚至可以说熟悉了相关 API 之后很容易。\n\n","link":"/posts/notes/client/other/vscode-plugin"},{"title":"Promise 具体实现","tags":["Promise"],"categories":["Notes","Client","Promise"],"author":"毛先生","excerpt":"\npromise 有三种状态 pending（进行中） fulfilled（已成功） rejected（已失败），只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n\n一旦从等待状态变成为其他状态就永远不能更改状态了。\n\n只有两种状态改变：\n\n- pending（进行中）–> fulfilled（已成功）\n- pending（进行中）–> rejected（已失败）\n\n","link":"/posts/notes/client/promise/implement"},{"title":"Promise 异步解决方案","tags":["Promise"],"categories":["Notes","Client","Promise"],"author":"毛先生","excerpt":"\n同步编程通常来说易于调试和维护，然而，异步编程通常能获得更好的性能和更大的灵活性。异步的最大特点是无需等待。 Promise 渐渐成为 JavaScript 里最重要的一部分，大量的新 API 都开始 Promise 原理实现。\n\n","link":"/posts/notes/client/promise"},{"title":"React 基本应用","tags":["react"],"categories":["Notes","Client","react"],"author":"毛先生","excerpt":"\nReact 中使用提供了数据绑定和各类时间的绑定，允许访问 React 的各生命周期对视图与数据进行处理，本篇介绍 React 的一些基本应用，在日常开发中都是必须掌握的技能。\n\n","link":"/posts/notes/client/react/baisc"},{"title":"React 面向组件编程","tags":["react"],"categories":["Notes","Client","react"],"author":"毛先生","excerpt":"\n在 React 的世界里“一切都是组件”， 组件可以映射作函数式编程中的函数，React 的组件和函数一样的灵活的特性不仅仅可以用于绘制 UI，还可以用于封装业务状态和逻辑，或者非展示相关的副作用, 再通过组合方式组成复杂的应用. 本文尝试解释用 React 组件的思维来处理常见的业务开发场景。\n\n","link":"/posts/notes/client/react/component"},{"title":"React Hooks","tags":["react"],"categories":["Notes","Client","react"],"author":"毛先生","excerpt":"\nReact Hooks 就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理 `state`，有 hooks 可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。\n\n","link":"/posts/notes/client/react/hooks"},{"title":"React 前端框架开发","tags":["react"],"categories":["Notes","Client","react"],"author":"毛先生","excerpt":"\nReact是用于构建用户界面的 JavaScript 库，起源于 Facebook 的内部项目，该公司对市场上所有 JavaScript MVC 框架都不满意，决定自行开发一套，用于架设 Instagram 的网站。于2013年5月开源。\n\n","link":"/posts/notes/client/react"},{"title":"React 面向路由编程","tags":["react"],"categories":["Notes","Client","react"],"author":"毛先生","excerpt":"\n单页 Web 应用（single page web），整个应用只有一个完整的页面，点击页面中的链接不会刷新页面, 本身也不会向服务器发请求，当点击路由链接时, 只会做页面的局部更新，数据都需要通过 ajax 请求获取, 并在前端异步展现。\n\n![](https://pic.imgdb.cn/item/62f1c0e716f2c2beb1e94b38.jpg)\n\nreact-router-dom 专门用于实现一个 SPA 应用，基于 react 的项目基本都会用到此库。\n\n","link":"/posts/notes/client/react/router"},{"title":"Ajax 异步数据传输","tags":["ajax"],"categories":["Notes","Client","request"],"author":"毛先生","excerpt":"\n`Ajax`并不是一项新技术，它实际上是几种技术，每种技术各尽其职，以一种全新的方式聚合在一起。\n- 服务器端语言，服务器需要具备向浏览器发送特定信息的能力，`Ajax` 与服务器端语言无关。\n- `XML (eXtensible Markup Language，可扩展标记语言)` 是一种描述数据的格式。`Aajx` 程序需要某种格式化的格式来在服务器和客户端之间传递信息，`XML` 是其中的一种选择。\n- `XHTML（eXtended Hypertext Markup Language）`,使用扩展超媒体标记语言）和 `CSS（Cascading Style Sheet,级联样式单）`标准化呈现；\n- `DOM（Document Object Model,文档对象模型）`实现动态显示和交互；\n- 使用 `XMLHTTP` 组件 `XMLHttpRequest` 对象进行异步数据读取，`JavaScript` 绑定和处理所有数据\n\n","link":"/posts/notes/client/request/ajax"},{"title":"Axios 接口请求工具库","tags":["http"],"categories":["Notes","Client","request"],"author":"毛先生","excerpt":"\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n## Axios 特性\n\n- 从浏览器中创建 [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n- 从 node.js 创建 [http](http://nodejs.org/api/http.html) 请求\n- 支持 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)\n\n","link":"/posts/notes/client/request/axios"},{"title":"HTTP 协议概述","tags":["http"],"categories":["Notes","Client","request"],"author":"毛先生","excerpt":"\nHTTP是一种用于获取诸如 HTML 文档之类的资源的协议。它是 Web 上任何数据交换的基础，它是一个客户端-服务器协议，这意味着请求由接收者发起，通常是 Web 浏览器。从提取的不同子文档（例如，文本、布局描述、图像、视频、脚本等）中重建完整的文档。\n\n","link":"/posts/notes/client/request/http"},{"title":"TypeScript 高级类型","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\n当了解到 typescript 的基础类型外，在开发过程中，为了应对多变的复杂场景，我们需要了解一下 typescript 的高级类型。所谓高级类型，是 typescript 为了保证语言的灵活性，所使用的一下语言特性。这些特性有助于我们应对复杂多变的开发场景。\n\n","link":"/posts/notes/client/typescript/advanced"},{"title":"TypeScript 类(Class)","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\nTypeScript 是面向对象的 JavaScript。类描述了所创建的对象共同的属性和方法。TypeScript 支持面向对象的所有特性，比如 类、接口等。\n\n","link":"/posts/notes/client/typescript/class"},{"title":"TypeScript 装饰器(Decorators)","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。可以这么说，装饰器监视一个方法，可以注入到类、方法、属性参数上扩展类、属性、方法、参数的功能。\n\n- 常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器\n- 装饰器的写法有：普通装饰器（无法传参）、装饰器工厂（可传参）\n\n装饰器是过去几年中JS最大的成就之一，已是ES7的标准特性之一\n\n装饰器的执行顺序：属性 > 方法 > 方法参数 > 类；\n\n","link":"/posts/notes/client/typescript/decorators"},{"title":"TypeScript 泛型(Generic)","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\n泛型，软件工程中，我们不仅要创建一致定义良好的API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时提供了十分灵活的功能。\n\n在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的语言。这样用户就可以以自己的数据类型来使用组件。\n\n通俗理解就是，泛型就是解决类、接口、方法的重用性、以及对不特定数据类型的支持。\n\n","link":"/posts/notes/client/typescript/generic"},{"title":"TypeScript 扩展语法","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\nTypeScript 提供了很多另类的语法与字段，可以用于定义和声明类型。\n\n## 声明对象中某个属性\n\n~~~ts\nconst obj = {\n  age: <string | number>60, // 不推荐\n  age: 60 as string | number\n}\nobj.age = '60'\n~~~\n\n","link":"/posts/notes/client/typescript/grammar"},{"title":"TypeScript 基础应用","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\nTypeScript 是一种由微软开发的[开源](https://baike.baidu.com/item/开源/246339)、跨平台的编程语言。它是[JavaScript](https://baike.baidu.com/item/JavaScript)的超集，最终会被编译为 JavaScript 代码。TypeScript 添加了可选的静态类型系统、很多尚未正式发布的ECMAScript新特性（如装饰器 ）。2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版 TypeScript。\n\n","link":"/posts/notes/client/typescript"},{"title":"TypeScript 接口(Interface)","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\n接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。\n\n","link":"/posts/notes/client/typescript/interface"},{"title":"TypeScript 命名空间(Namespace)","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\n在代码量较大的情况下，为了避免各种变量命名产生冲突，可将相似功能的函数、类、接口等放置到命名空间内。\n\n同Java的包、.Net的命名空间一样，TypeScript的命名空间可以将代码包括起来，支队外暴露需要在外部访问的对象。命名空间内对象或者属性需要通过export暴露出去，才能在外部访问。\n\n","link":"/posts/notes/client/typescript/namespace"},{"title":"TypeScript 数据类型","tags":["TypeScript"],"categories":["Notes","Client","TypeScript"],"author":"毛先生","excerpt":"\njavascript 中有 7 种数据类型，分别是：boolean，number，string，null，undefined和object，以及在 ES6 中新增的一种类型 symbol。而typescript又在此基础上增加了一些类型。\n\n","link":"/posts/notes/client/typescript/types"},{"title":"JavaScript 工具库(Lodash)","tags":["JavaScript","lodash","utils"],"categories":["Notes","Client","utils"],"author":"毛先生","excerpt":"\nLodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。\n\nLodash 遵循 MIT 开源协议发布，并且支持最新的运行环境。 查看各个构件版本的区别并选择一个适合你的版本。\n\n该笔记为记录比较常用的方法，一些可通过 ES6 方式实现的，以及不是很重要的都进行了跳过和筛选，为个人使用记录文档。\n\n","link":"/posts/notes/client/utils/lodash"},{"title":"NPM 软件包管理工具","tags":["npm"],"categories":["Notes","Client","utils"],"author":"毛先生","excerpt":"\n`CommonJS`包规范是理论，`NPM (Node Package Manager)` 是其中一种实践。对于`Node`而言，`NPM`帮助其完成了第三方模块的发布、安装和依赖等。借助`NPM`，`Node`与第三方模块之间形成了很好的一个生态系统。\n\n","link":"/posts/notes/client/utils/npm"},{"title":"JavaScript 工具库(Zepto)","tags":["JavaScript","zepto","utils"],"categories":["Notes","Client","utils"],"author":"毛先生","excerpt":"\nZepto是一个轻量级的、针对现代高级浏览器的JavaScript工具库, 它兼容jQuery的API。Zepto是一款开源软件, 它采用的是对开发者和商业都很友好的开源协议--MIT license, 并具有以下特点：\n\n- 体积 8kb\n- 针对移动端的框架\n- 同 `jquery` 大部分一样, 都是 `$` 为核心函数\n- 功能完善\n\n","link":"/posts/notes/client/utils/zepto"},{"title":"Vite 原理分析实现","tags":["Vite"],"categories":["Notes","Client","Vite"],"author":"毛先生","excerpt":"\n## Vite 是什么\n\n`Vite`，一个基于浏览器原生 `ES imports` 的开发服务器。利用浏览器去解析 `imports`，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 `Vue` 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 `rollup` 打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。\n\n- 快速冷启动服务器\n- 即时热模块更换（HMR）\n- 真正的按需编译\n\n","link":"/posts/notes/client/vite"},{"title":"Vue 基本应用","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统，以操作数据的方式操作 DOM 节点，Vue 不建议使用者直接操作节点内容，目前大部分开发平台都倡导以修改数据的方式操作节点，操作节点被认为是一种落后的技术。\n\n","link":"/posts/notes/client/vue/basic"},{"title":"Vue 面向组件编程","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。\n\n组件化编程又有两种写法，分别是非单文件组件和单文件组件，而非单文件组件在真正开发中几乎不用，所以在这里就主要写单文件组件的写法。\n\n","link":"/posts/notes/client/vue/component"},{"title":"Vue3 组合式 API","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。Vue3 使用组合式 API 的地方为 setup，在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API） 允许我们编写更有条理的代码。\n\n","link":"/posts/notes/client/vue/composition-api"},{"title":"Vue 渐进式前端框架","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。\n\n","link":"/posts/notes/client/vue"},{"title":"Vue 面向路由编程","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌！！！\n\n路由组件装载着需要的内容，通常这类组件放在 `src/views` 文件夹内(About.vue、Home.vue)\n\n","link":"/posts/notes/client/vue/router"},{"title":"Vue3 路由的变化","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue Router 4.0 提供了 Vue 3 支持， 虽然 vue-router 4 大多数 API 保持不变，但是在 vue3 中以插件形式存在，所以在使用时有一定的变化。\n\n\n路由组件装载着需要的内容，通常这类组件放在 `src/pages` 文件夹内`(about.vue、home.vue)`\n\n","link":"/posts/notes/client/vue/vue3-router"},{"title":"Vue3 内置组件 Suspense","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nSuspense 组件用于在等待某个异步组件解析时显示后备内容。\n\n以下是异步组件有用的一些实例：\n\n- 在页面加载之前显示加载动画\n- 显示占位符内容\n- 处理延迟加载的图像\n\n以前，在 Vue2 中，我们必须使用条件(例如 `v-if` 或 `v-else`)来检查我们的数据是否已加载并显示后备内容。\n\n但是现在，Suspense 随 Vue3 内置了，因此我们不必担心跟踪何时加载数据并呈现相应的内容。\n\n","link":"/posts/notes/client/vue/vue3-suspense"},{"title":"Vue3 新特性与更改","tags":["vue"],"categories":["Notes","Client","vue"],"author":"毛先生","excerpt":"\nVue3 在 2020年9月18日，官方正式将其取名为 Vue3 One Piece。新版本的Vue提供了更好的性能，更小的打包体积，更好的TypeScript支持，还有一些新的API。\n\n","link":"/posts/notes/client/vue/vue3"},{"title":"Vue 源码之 Virtual DOM|diff","tags":["vue","core"],"categories":["Notes","Client","vueCore"],"author":"毛先生","excerpt":"\n## Diff 算法是什么？\n\n例如一次挪动家具，在我们 Vue 当中，一次渲染则代表一次挪动家具\n\n![image-20220324194519246](./images/image-20220324194519246.png)\n\n在程序中，对一个数据的更改如果不通过 diff，就例如将整个家拆掉在重新建，这样效率太低，代价太昂贵。\n\n![image-20220324194644589](./images/image-20220324194644589.png)\n\ndiff 算法就是程序中进行精细化对比，实现最小量的更新。  \n\n","link":"/posts/notes/client/vue-core/diff-virtual-dom"},{"title":"Vue 源码之 JavaScript 技术","tags":["vue","core"],"categories":["Notes","Client","vueCore"],"author":"毛先生","excerpt":"\n学习期间记录一些 Vue 源码使用的相关 JavaScript 技术。\n\n","link":"/posts/notes/client/vue-core"},{"title":"Vue 源码之 mustache 模板引擎","tags":["vue","core"],"categories":["Notes","Client","vueCore"],"author":"毛先生","excerpt":"\n## Vue 模板引擎是什么？\n\n模板引擎指 Vue Template 中渲染数据的模板解析引擎，例如常见的 `v-for`、`v-if`、`v-show` 等等，模板引擎是将数据变为视图最优雅的解决方案。\n\n","link":"/posts/notes/client/vue-core/mustache"},{"title":"H5 原生 Web 适配","tags":["Mobile","Html"],"categories":["Notes","Client","Web Mobile"],"author":"毛先生","excerpt":"\nhtml 在 WebView 中存在各种适配情况：比如标签宽度、图片大小、字体大小等。\n\n## 利用 rem 适配\n\n**优点**：没有破坏完美视口，**缺点**：px值到rem的转换太复杂\n\n~~~css\n/* em  自身标签font-size的大小 */\ndiv{width: 10em;height: 10em;}\n/* rem 根标签的font-size的大小 */\ndiv{width: 10rem;height: 10rem;}\n/* 谷歌下字体的默认大小为16px */\n/* 谷歌下字体的最小大小为12px */\n~~~\n\n","link":"/posts/notes/client/web-mobile/adaptation"},{"title":"H5 原生 Web 基本应用","tags":["Mobile","Html"],"categories":["Notes","Client","Web Mobile"],"author":"毛先生","excerpt":"\n## UIVew 像素\n\nUIVew: 1px 在不同像素比中，对应的物理像素数量是不一样的，例如：像素比为 2 的手机上，1px 对应 2 个物理像素，与之对应的像素比 1 的实际对比，像素比2的手机分栏线就会显得很粗。那这个时候在分栏线中，如何让 1px 值对应一个物理像素，这就显得很重要。\n\n","link":"/posts/notes/client/web-mobile/apply"},{"title":"H5 原生 Web 应用概念","tags":["Mobile","Html"],"categories":["Notes","Client","Web Mobile"],"author":"毛先生","excerpt":"\n## 移动 APP 开发的三种常见模式\n\n- Web App\n\nWAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。\n\n- Native App\n\nNative App 是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序，也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。\n\n- Hybrid App\n\nHybrid App（混合模式移动应用）是指介于 web-app、native-app 这两者之间的app，兼具“Native App良好[用户](https://baike.baidu.com/item/用户/3621489)交互体验的优势”和“Web App跨平台开发的优势”。\n\n","link":"/posts/notes/client/web-mobile"},{"title":"H5 原生 Web 屏幕概念","tags":["Mobile","Html"],"categories":["Notes","Client","Web Mobile"],"author":"毛先生","excerpt":"\n## 移动端屏幕基本概念\n\n- 屏幕尺寸\n\n指屏幕的对角线的长度，单位是英尺，1英尺 = 2.54厘米\n常见的屏幕尺寸有 `2.4、2.8/3.5、3.7、、4.2、5.0、5.5、6.0` 等\n\n![](https://pic.imgdb.cn/item/62f233ba16f2c2beb1de1214.jpg)\n\n- 屏幕分辨率\n\n横纵向上物理像素的个数。设备出厂时，该款设备所包含的物理像素的点数和一个物理像素所占据的实际屏幕尺寸是包含变的，是固定的。\n\n- 屏幕密度\n\n每英寸上物理像素的个数，取决于屏幕是否是高清屏。\n\n","link":"/posts/notes/client/web-mobile/screen"},{"title":"H5 原生 Web 滚动方案","tags":["Mobile","Html"],"categories":["Notes","Client","Web Mobile"],"author":"毛先生","excerpt":"\n## Web 移动端滚动\n\n在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的div内触发，将该 `div` 设置成 `overflow:scroll/auto`; 来形成 `div` 内","link":"/posts/notes/client/web-mobile/scroll"},{"title":"Apollo Client GraphQl 客户端方案","tags":["Apollo Client"],"categories":["Notes","Server","GraphQL"],"author":"毛先生","excerpt":"\nApollo Client 是一个全功能的 GraphQL 客户端解决方案，用于任何现代前端开发框架的交互。它允许你轻松通过 GraphQL 获取数据并构建 UI 组件。并支持与 VSCode 配合，支持从 GraphQL 服务器中读取信息从而实现代码提示。\n\n","link":"/posts/notes/server/graphql/apollo-client"},{"title":"Apollo Server GraphQL Web 开发框架","tags":["Apollo Server"],"categories":["Notes","Server","GraphQL"],"author":"毛先生","excerpt":"\napollo-server 来自于 Apollo 的一套 GraphQL server 包，可用于多种 Node.js HTTP 框架（Express，Connect，Hapi，Koa 等）。\n\n以及拥有客户端中的实现，如：[Apollo Client](http://apollographql.com/client/) ([github](https://github.com/apollographql/apollo-client))\n\n","link":"/posts/notes/server/graphql/apollo-server"},{"title":"GraphQL 数据库查询语言","tags":["GraphQL"],"categories":["Notes","Server","GraphQL"],"author":"毛先生","excerpt":"\nGraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。它跟 SQL 的关系是共用 QL 后缀，就好像「汉语」和「英语」共用后缀一样，但他们本质上是不同的语言。GraphQL 跟用作存储的 NoSQL 没有必然联系，虽然 GraphQL 背后的实际存储可以选择 NoSQL 类型的数据库，但也可以用 SQL 类型的数据库，或者任意其它存储方式（例如文本文件、存内存里等等）。\n\n","link":"/posts/notes/server/graphql"},{"title":"MongoDB 基本应用","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\nMongoDB 用 C++ 高效地实现了底层的数据读写等功能，对外提供的操作 API 规则|调用方式，使用了 JavaScript 来实现，客户端中使用的命令与 JavaScript 极度相似。\n\n","link":"/posts/notes/server/mongodb/basic"},{"title":"MongoDB 数据查询","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\n在关系型数据库中，可以实现基于表的各种各样的查询，以及通过投影来返回指定的列，相应的查询功能也可以在 MongoDB 中实现。同时由于 MongoDB 支持嵌套文档和数组，MongoDB 也可以实现基于嵌套文档和数组的查询。\n\n","link":"/posts/notes/server/mongodb/find"},{"title":"MongoDB 分布式关系数据库","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似 `json` 的 `bson` 格式，因此可以存储比较复杂的数据类型。Mongo 最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。\n\n在 MongoDB 中，数据库（database）和集合（collection）都不需要手动创建，当我们创建文档（document）时，如果文档所在的集合或数据库不存在会自动创建数据库和集合。\n\n","link":"/posts/notes/server/mongodb"},{"title":"MongoDB 查询操作符","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\n查询操作符(Query Operators)可以让我们写出复杂查询条件，让我们使用的过程更加灵活。\n\n","link":"/posts/notes/server/mongodb/operator-find"},{"title":"MongoDB 查询操作符","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\n默认情况下 update 会使用新文档覆盖旧文档 如果不想覆盖而是仅仅想更新其中的某些字段 那么我们就需要使用 update 的更新操作符。\n\n","link":"/posts/notes/server/mongodb/operator-update"},{"title":"MySQL 基本应用","tags":["MySQL"],"categories":["Notes","Server","MySQL"],"author":"毛先生","excerpt":"\n## 数据类型\n\n数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。有一些数据是要存储为数字的，数字当中有些是要存储为整数、小数、日期型等...\n\n","link":"/posts/notes/server/mysql/apply"},{"title":"MySQL 常用函数","tags":["MySQL"],"categories":["Notes","Server","MySQL"],"author":"毛先生","excerpt":"\nMySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。\n\n","link":"/posts/notes/server/mysql/function"},{"title":"MySQL 关系型数据库管理系统","tags":["MySQL"],"categories":["Notes","Server","MySQL"],"author":"毛先生","excerpt":"\nMySQL是一个**[关系型数据库管理系统](https://baike.baidu.com/item/关系型数据库管理系统/696511)**，由瑞典MySQL AB 公司开发，属于 [Oracle](https://baike.baidu.com/item/Oracle) 旗下产品。MySQL 是最流行的[关系型数据库管理系统](https://baike.baidu.com/item/关系型数据库管理系统/696511)之一，在 WEB 应用方面，MySQL是最好的 [RDBMS](https://baike.baidu.com/item/RDBMS/1048260) (Relational Database Management System，关系数据库管理系统) 应用软件之一。\n\n","link":"/posts/notes/server/mysql"},{"title":"MySQL 案例练习","tags":["MySQL"],"categories":["Notes","Server","MySQL"],"author":"毛先生","excerpt":"\n根据课堂学习的内容进行案例练习，熟系 MySQL 的各种创建、删除、修改还有其他各种数据库操作。\n\n","link":"/posts/notes/server/mysql/practise"},{"title":"NodeJS 缓冲区（Buffer）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"JS 数组性能比其他语言的数组差，但 Buffer 中的内存不是通过 JavaScript 分配的，而是在底层通过 C++ 申请的，也就是我们可以直接通过 Buffer 来创建内存中的空间。\n\n","link":"/posts/notes/server/nodejs/buffer"},{"title":"NodeJS 加密系统（crypto）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\n`crypto` 模块提供了加密功能，实现了包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。`Hash` 类是用于创建数据加密哈希值的工具类。\n\n查看 crypto 模块支持的 hash 函数：`crypto.getHashes()`\n\n","link":"/posts/notes/server/nodejs/crypto"},{"title":"NodeJS 文件系统（fs）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\n在 Node.js 中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端。Node.js 通过 fs 模块来和文件系统进行交互。该模块提供了一些标准文件访问 API 来打开、读取、写入文件，以及与其交互。要使用 fs 模块，首先需要对其进行加载。\n\n","link":"/posts/notes/server/nodejs/fs"},{"title":"NodeJS 服务模块（http|s）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\n在 NodeJS 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的 http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务\n\nNodeJS 自身就可以用来构建服务器，而且 http|s 模块是由 C++ 实现的，性能可靠。\n\n","link":"/posts/notes/server/nodejs/http"},{"title":"NodeJS 服务端 JavaScript 解释器","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\nNode.js 发布于2009年5月，由 Ryan Dahl 开发，是一个基于 [Chrome](https://baike.baidu.com/item/Google%20Chrome/5638378?fromtitle=Chrome&fromid=5633839) [V8](https://baike.baidu.com/item/V8/6178125) 引擎的 JavaScript 运行环境，使用了一个事件驱动、非阻塞式I/O模型，让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与 PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 \n\n","link":"/posts/notes/server/nodejs"},{"title":"NodeJS CommonJS 规范","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\n如果程序设计的规模达到了一定程度，则必须对其进行模块化，模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制。Node.js 执行的 CommonJS 模块功能可以帮我们解决该问题。\n\n","link":"/posts/notes/server/nodejs/module"},{"title":"NodeJS 操作系统（os）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\nos 模块是 Node.js 官方提供的，可以获取操作系统的一些参数，如操作系统CPU架构、CPU内核信息、空闲系统内存等。\n\n","link":"/posts/notes/server/nodejs/os"},{"title":"NodeJS 路径系统（path|url）","tags":["NodeJS"],"categories":["Notes","Server","NodeJS"],"author":"毛先生","excerpt":"\npath 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性,用来满足用户对路径的处理需求。\n\n","link":"/posts/notes/server/nodejs/path"},{"title":"PHP 基本应用","tags":["PHP"],"categories":["Notes","Server","PHP"],"author":"毛先生","excerpt":"\n## 基本语法\n\n~~~php\n<?php // 代表php代码的开始\n// 由$为前缀定义变量\n$count_1 = 50;\n$count_2 = 50;\nif ($count_1 == $count_2) {\n  echo '数值匹配成功'; // 输出语句, 浏览器访问时自动被编译为字符串\n  unset($count_1); // 卸除变量\n  echo $count_1; // 变量卸除后, 变量一则不存在, echo无任何效果\n    \n  // 错误抑制符\n  @('wadwada'+'wdwandia');\n    \n  // 模板字符串\n  echo \"count_1:{$count_1}\"\n}\n?> // 代表php代码的结束, 不填写默认在编译时自动添加\n~~~\n\n","link":"/posts/notes/server/php/apply"},{"title":"PHP 系统错误代号","tags":["PHP"],"categories":["Notes","Server","PHP"],"author":"毛先生","excerpt":"\nphp 中所有看到的错误代码在 php 中都被定义成了系统常量（可以直接使用）\n\n\n## 系统错误\n\n~~~php\nE_PARSE; // 编译错误\nE_ERROR; // fatal error 致密错误, 会导致代码不能正确继续执行（出错的位置断掉）\nE_WARNING; // warning 警告错误, 不会影响代码执行, 但可能得到意想不到的结果\nE_NOTICE; // notice 通知错误, 不会影响代码执行\n~~~\n\n","link":"/posts/notes/server/php/error-code"},{"title":"PHP 扩展方法","tags":["PHP"],"categories":["Notes","Server","PHP"],"author":"毛先生","excerpt":"\n## php 字符串扩展\n\n~~~php\nheader('Content-type:text/html;charset=utf-8');\n$str1 = '151651323';\n$str2 = '你好中国123';\n// 得到字符串字节数-> 9 15\necho strlen($str1), strlen($str2);\n~~~\n\n","link":"/posts/notes/server/php/function"},{"title":"PHP 服务器端脚本语言","tags":["PHP"],"categories":["Notes","Server","PHP"],"author":"毛先生","excerpt":"\nPHP即“[超文本](https://baike.baidu.com/item/超文本)[预处理器](https://baike.baidu.com/item/预处理器)”，是一种通用[开源](https://baike.baidu.com/item/开源/246339)[脚本语言](https://baike.baidu.com/item/脚本语言/1379708)。PHP是在服务器端执行的脚本语言，与[C语言](https://baike.baidu.com/item/C语言/105958)类似，是常用的网站编程语言。PHP独特的语法混合了C、[Java](https://baike.baidu.com/item/Java/85979)、[Perl](https://baike.baidu.com/item/Perl/851577)以及 PHP 自创的语法。利于学习，使用广泛，主要适用于[Web](https://baike.baidu.com/item/Web/150564)开发领域。\n\n","link":"/posts/notes/server/php"},{"title":"Python 编程语言基础","tags":["Python"],"categories":["Notes","Server","Python"],"author":"毛先生","excerpt":"\nPython 由荷兰数学和计算机科学研究学会的[吉多·范罗苏姆](https://baike.baidu.com/item/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86/328361?fromModule=lemma_inlink)于 1990 年代初设计，作为一门叫做 [ABC 语言](https://baike.baidu.com/item/ABC%E8%AF%AD%E8%A8%80/334996?fromModule=lemma_inlink)的替代品。 Python 提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及[解释型语言](https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/8888952?fromModule=lemma_inlink)的本质，使它成为多数平台上写脚本和快速开发应用的编程语言， 随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。\n\nPython 解释器易于扩展，可以使用C语言或C++（或者其他可以通过C调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。Python 丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。\n\n","link":"/posts/notes/server/python"},{"title":"ESBuild 基于 GO 的 JS|TS 编译器","tags":["grunt"],"categories":["Notes","Client","bundler"],"author":"毛先生","excerpt":"\nesbuild 是一个用 go 语言写的 javascript, typescript 打包工具，速度比 webpack 快 100 倍以上。\n\n","link":"/posts/notes/client/module/builds/esbuild"},{"title":"Grunt 基本应用(1.x)","tags":["Grunt"],"categories":["Notes","Client","Bundler"],"author":"毛先生","excerpt":"\nGrunt 是一套前端自动化构建工具，基于 nodeJs 的命令行工具，它是一个任务运行器, 配合其丰富强大的插件(plugins)系统。基于插件，它可以实现：\n\n- 合并文件 `(js/css)`\n- 压缩文件 `(js/css)`\n- 语法检查 `(js)`\n- 编译处理 `less/sass`\n- 热编译或其它...\n\n","link":"/posts/notes/client/module/builds/grunt"},{"title":"Gulp 基本应用(4.x)","tags":["Gulp"],"categories":["Notes","Client","Bundler"],"author":"毛先生","excerpt":"\nGulp 是与 Grunt 功能类似的前端项目构建工具, 基于`Nodejs`的自动任务运行器，能自动化地完成 ` javascript/coffee/sass/less/html/image/css ` 等文件的合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务，此外，Gulp 比 Grunt 更高效(异步多任务), 更易于使用, 插件也具有更高的质量。\n\n","link":"/posts/notes/client/module/builds/gulp"},{"title":"Rollup - JavaScript 常用插件","tags":["grunt"],"categories":["Notes","Client","bundler"],"author":"毛先生","excerpt":"\nRollup 具有丰富的插件生态，我们日常的开发也离不开这些插件，在这里整理了一些常用的 Rollup Plugin Packages。\n\n","link":"/posts/notes/client/module/builds/rollup-plugin"},{"title":"Rollup - JavaScript 模块打包器","tags":["grunt"],"categories":["Notes","Client","bundler"],"author":"毛先生","excerpt":"\nRollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。\n\n> 官方简述：Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。\n\n可以看出 rollup 是以 ES6 模块化为基调的打包工具，rollup 可以支持 ES6 模块转换为 iife、cjs、umd 模块，支持打包后 浏览器、Node 环境运行，使用 [rollup-plugin-commonjs](https://github.com/rollup/rollup-plugin-commonjs) 还可以导入 commonjs 模块。\n\n","link":"/posts/notes/client/module/builds/rollup"},{"title":"AMD-RequireJS 模块化","tags":["JavaScript Modules"],"categories":["Notes","Client","JavaScript Modules"],"author":"毛先生","excerpt":"\n\nAMD规范主要是解决各个模块之间的依赖关系，可以顺序的加载js模块，但是却是异步加载，不会影响页面的css和html标签的加载。\n\nAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范。\n\n由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出\nrequireJS主要解决两个问题\n\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\n\n","link":"/posts/notes/client/module/history/amd"},{"title":"Browserify 模块化","tags":["JavaScript Modules"],"categories":["Notes","Client","JavaScript Modules"],"author":"毛先生","excerpt":"\nBrowserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。\n\n","link":"/posts/notes/client/module/history/browserify"},{"title":"ECMAScript6 模块化","tags":["JavaScript Modules"],"categories":["Notes","Client","JavaScript Modules"],"author":"毛先生","excerpt":"\n在 ES6 模块化规范诞生之前，Javascript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。\n\n但是，这些社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准，例如：\n- AMD 和 CMD 适用于浏览器端的 Javascript 模块化\n- CommonJS 适用于服务器端的 Javascript 模块化\n\n因此，ES6 语法规范中，在语言层面上定义了 ES6 模块化规范，是浏览器端与服务器端通用的模块化开发规范。\n\nES6模块化规范中定义：\n\n- 每个 js 文件都是一个独立的模块\n- 导入模块成员使用 import 关键字\n- 暴露模块成员使用 export 关键字\n\n","link":"/posts/notes/client/module/history/es6"},{"title":"JavaScript 模块化演进","tags":["JavaScript Modules"],"categories":["Notes","Client","JavaScript Modules"],"author":"毛先生","excerpt":"\nES2015 在2015年6月正式发布，官方终于引入了对于模块的原生支持，如今 JS 的模块化开发非常的方便、自然，但这个新规范仅仅持续了3年。就在7年前，JS 的模块化还停留在运行时的支持；13年前，通过后端模版定义、注释定义模块依赖。对于经历过的人来说，历史的模块化方式还停留在脑海中，久久不能忘怀。\n\n","link":"/posts/notes/client/module/history"},{"title":"Webpack 基本应用","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\nwebpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)\n\n## 五个核心\n\n- **entry**   指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。\n- **output**  指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。\n- **loader**  loader 让 webpack 能够去处理那些 非 JavaScript 文件 (webpack 自身只理解 JavaScript)\n- **plugins** 可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。\n- **mode**    指示 webpack 使用相应模式的配置。\n\n","link":"/posts/notes/client/module/webpack/basic"},{"title":"Webpack 详细配置","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\n## 主入口(entry)\n\n`entry: './src/index.js'`\n\n打包形成一个`chunk`，输出一个`bundle`文件。此时 chunk 的名称默认是 `main`。\n\n`entry: ['./src/index.js', './src/add.js']`\n\n所有接口文件最终只会形成一个`chunk`, 输出一个`bundle`文件。在用 `HMR` 热加载的时候，让 `html` 生效的时候加上`html` 文件的路径，此时 `chunk` 的名称是`main`。\n\n`entry: { key: value, key: value }`\n\n有几个入口文件就形成几个`chunk`，输出几个`bundle`文件， 此时`chunk`的名称是 `key`\n\n","link":"/posts/notes/client/module/webpack/detail"},{"title":"Webpack 开发环境","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\n用于在 dev 模式中的配置（loader、plugin）提供开发服务器、HOT 热更新、编译捆绑 less、css、javascript 或其他资源。\n\n","link":"/posts/notes/client/module/webpack/dev"},{"title":"Webpack 生产环境","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\n## 提取样式文件(CSS)\n\n```sh\nnpm i mini-css-extract-plugin -D\n```\n\n~~~js\nconst { resolve } = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n// 引入CSS提取文件插件\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: { filename: 'js/built.js', path: resolve(__dirname, 'build') },\n  mode: 'development',\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 提取 webpack 中的 css 成单独文件\n          MiniCssExtractPlugin.loader,\n          // 合并 css 存入 webpack\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    // 自动解析打包内容并复制解析创建 html\n    new HtmlWebpackPlugin({ template: './src/index.html' }),\n    // 设置 css 文件结构与名字\n    new MiniCssExtractPlugin({ filename: 'css/built.css' })\n    // 当 html 创建时会自动引入 css 独立文件\n  ]\n}\n~~~\n\n","link":"/posts/notes/client/module/webpack/prod"},{"title":"微信小程序开发基础","tags":["Mini Program"],"categories":["Notes","Client","Mini Program"],"author":"毛先生","excerpt":"\n## 事件绑定\n\n~~~html\n<!-- bind冒泡事件 -->\n<view bind:tap=\"myEventCallBack\">点击</view>\n<!-- catch阻止冒泡事件 -->\n<view catch:tap=\"myEventCallBack\">点击</view>\n<!-- mut-bind阻止冒泡事件 -->\n<view mut-bind:tap=\"myEventCallBack\">点击</view>\n<!-- 滑动事件, 具有滑动值 -->\n<view bindscroll=\"scroll\"></view>\n~~~\n\n~~~js\nPage({\n  myEventCallBack(ev) {\n    console.log(ev)\n  }\n})\n~~~\n\n","link":"/posts/notes/client/multi-terminal/mini-program/basic"},{"title":"微信小程序组件开发","tags":["Mini Program"],"categories":["Notes","Client","Mini Program"],"author":"毛先生","excerpt":"\n我们知道了微信小程序的视图层，而视图层还包括了组件。以下，总结微信小程序的常用组件，并自定义自己的组件。\n\n","link":"/posts/notes/client/multi-terminal/mini-program/component"},{"title":"微信小程序应用","tags":["Mini Program"],"categories":["Notes","Client","Mini Program"],"author":"毛先生","excerpt":"\n微信小程序，小程序的一种，英文名Wechat Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。\n\n小程序没有 DOM 对象，一切基于组件化。\n\n","link":"/posts/notes/client/multi-terminal/mini-program"},{"title":"mpvue 小程序开发框架","tags":["Mini Program"],"categories":["Notes","Client","mpvue"],"author":"毛先生","excerpt":"\n\nmpVue (Vue in Mini Program) 美团工程师推出的基于 Vue.js 封装的用于开发小程序的框架，融合了原生小程序和 Vue.js 的特点，可完全组件化开发。\n\nmpvue 具有组件化开发、完整 Vue.js 的开发体验、可使用 Vue 第三方扩展插件、Webpack 构建项目、最终 H5 转换工具将项目编译成小程序识别的文件。\n\n","link":"/posts/notes/client/multi-terminal/mpvue"},{"title":"微信公众号服务接入","tags":["Official Account"],"categories":["Notes","Client","Official Account"],"author":"毛先生","excerpt":"\n微信公众平台,是给个人、企业和组织提供业务服务与用户管理能力的全新服务平台。简单来说，一个提供服务平台。\n\n注册微信公众号：https://mp.weixin.qq.com/\n\n登录后，页面左边将会有一排功能选项，订阅号中一共有5个功能可以直接设置使用。\n\n![](https://pic.imgdb.cn/item/62f4c86416f2c2beb1c498c5.jpg)\n\n","link":"/posts/notes/client/multi-terminal/official-account"},{"title":"微信公众号接口凭证","tags":["Official Account"],"categories":["Notes","Client","Official Account"],"author":"毛先生","excerpt":"\n`access_token` 是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用 `access_token`。开发者需要进行妥善保存。`access_token` 的存储至少要保留 512 个字符空间。`access_token` 的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的 `access_token` 失效。\n\n","link":"/posts/notes/client/multi-terminal/official-account/interface"},{"title":"微信公众号 JS-SDK 开发","tags":["Official Account"],"categories":["Notes","Client","Official Account"],"author":"毛先生","excerpt":"\n微信 JS-SDK ( JavaScript Software Development Kit )是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。\n\n通过使用微信 JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。\n\n简单来说，使用JS-SDK我们可以引入外部网页并使用微信公众号提供的API。\n\n","link":"/posts/notes/client/multi-terminal/official-account/js-sdk"},{"title":"微信公众号爬取数据（Puppeteer）","tags":["Official Account"],"categories":["Notes","Client","Official Account"],"author":"毛先生","excerpt":"\nPuppeteer 是 Chrome 开发团队在 2017 年发布的一个 Node.js 包，用来模拟 Chrome 浏览器的运行。它具有以下特点：\n\n- 网页截图或者生成 PDF\n- 爬取 SPA 或 SSR 网站\n- UI 自动化测试，模拟表单提交，键盘输入，点击等行为\n- 捕获网站的时间线，帮助诊断性能问题\n- 创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例\n- 测试 Chrome 扩展程序\n\n","link":"/posts/notes/client/multi-terminal/official-account/puppeteer"},{"title":"微信公众号数据管理（Qiniu）","tags":["Official Account"],"categories":["Notes","Client","Official Account"],"author":"毛先生","excerpt":"\n七牛对象存储将数据文件以资源的形式上传到空间中。可以创建一个或者多个空间，然后向每个空间中上传一个或多个文件。通过获取已上传文件的地址进行文件的分享和下载。还可以通过修改存储空间或文件的属性或元信息来设置相应的访问权限。[对象储存产品手册](https://developer.qiniu.com/kodo)\n\n","link":"/posts/notes/client/multi-terminal/official-account/qiniu"},{"title":"uniapp 多端开发框架","tags":["Mini Program"],"categories":["Notes","Client","Uniapp"],"author":"毛先生","excerpt":"\n`uni-app` 是一个使用 [Vue.js](https://vuejs.org/) 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。\n\n","link":"/posts/notes/client/multi-terminal/uniapp"},{"title":"uniapp 中安卓与 ios 审核流程","tags":["Mini Program"],"categories":["Notes","Client","Uniapp"],"author":"毛先生","excerpt":"\n## 关于 Android 证书\n\nAndroid 平台打包发布 apk 应用，需要使用数字证书（.keystore文件）进行签名，用于表明开发者身份。\n\nAndroid 证书的生成是自助和免费的，不需要审批或付费。\n\n可以使用JRE环境中的 keytool 命令生成。以下是windows平台生成证书的方法：\n\n","link":"/posts/notes/client/multi-terminal/uniapp/uni-android-ios"},{"title":"Jest 自动化部署测试钩子","tags":["Test"],"categories":["Notes","Client","Test"],"author":"毛先生","excerpt":"\n写测试的时候你经常需要在运行测试前做一些准备工作，和在运行测试后进行一些整理工作。 Jest 提供辅助函数来处理这个问题。\n\n","link":"/posts/notes/client/test/jest/hooks"},{"title":"Jest 自动化部署测试配置","tags":["Test"],"categories":["Notes","Client","Test"],"author":"毛先生","excerpt":"\n随着前端的发展，项目变的越来越复杂，这时候就引入前端工程化的概念，有人认为前端工程化就是高质量的代码设计，高质量的代码实践，就是前端工程化。其实工程化还有一个很重要的环节，就是自动化代码测试。\n\n随着前端的发展，前端设计的领域已经越来越多，也越来越复杂。这就对我们前端工程化能力，提出了更高的要求。 好的前端工程化一般包括三个大的方面：\n\n- 前端自动化测试（前提条件）\n- 高质量的代码设计\n- 高质量的代码实现\n\n虽然一些公司，到现在还是没有前端自动化测试，甚至 BOSS 会说前端自动化测试会拉低工作效率，认为用处不大。这是完全错误的想法，你可以看到 Github 上任何大型的前端项目都有自动化测试代码。\n\n- Ant Design : React UI 组件库\n- Vue.js : 国内最流行的构建用户界面的渐进式 JavaScript 框架。\n- React.js : 世界最流行的 JavaScript MVC 框架。\n\n","link":"/posts/notes/client/test/jest"},{"title":"Jest 自动化部署测试匹配器","tags":["Test"],"categories":["Notes","Client","Test"],"author":"毛先生","excerpt":"\n在项目根目录，新建两个文件，一个文件是 `index.js`(被测试文件)，另一个是 `index.test.js`（测试文件）文件。\n\n`index.js` 文件比如是我们写的一些业务逻辑方法，我们就那他当一个例子，最后要测试的就是这个文件。我们来模仿一次去按摩的经历。\n\n","link":"/posts/notes/client/test/jest/matcher"},{"title":"Jest 自动化部署异步测试","tags":["Test"],"categories":["Notes","Client","Test"],"author":"毛先生","excerpt":"\n在工作中我们很多方法都包含异步操作，所以测试异步代码成了工作中必不可少的一部分。\n\n","link":"/posts/notes/client/test/jest/promise"},{"title":"Mongoose 对象异步模型框架","tags":["MongoDB"],"categories":["Notes","Server","MongoDB"],"author":"毛先生","excerpt":"\nMongoose 是设计用于异步环境的 MongoDB 对象模型工具，支持 promises 和 callbacks，Mongoose 为模型提供了一种直接的，基于 `scheme` 结构去定义你的数据模型。它内置数据验证，查询构建，业务逻辑钩子等，开箱即用。\n\n在学习 Mongoose 的过程中需要熟悉一些名词：\n\n- `Schema`: 一种以文件形式存储的数据库模型模式，不具备数据库的操作能力\n- `Model`:  由 Schema 发布生成的模型，具有抽象属性和数据库操作能力\n- `Entity`: 由 Model 创建的实例，也能操作数据库\n\n","link":"/posts/notes/server/mongodb/mongoose"},{"title":"Express Web 开发框架","tags":["Express"],"categories":["Notes","Server","Express"],"author":"毛先生","excerpt":"\n\nExpress 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。\n可以选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API。Express 还提供精简的基本 Web 应用程序功能，而不会隐藏了解和青睐的 Node.js 功能。许多流行的开发框架 都基于 Express 构建。\n\n","link":"/posts/notes/server/nodejs/express"},{"title":"Express 常用中间件","tags":["Express"],"categories":["Notes","Server","Express"],"author":"毛先生","excerpt":"\nExpress 是一个自身功能 极简,完全是由路由和中间件构成的一个web开发框架，从本质上来说，一个Express 应用就是在调用各种中间件，而 Express 具有很多第三方中间件可以使用。\n\n","link":"/posts/notes/server/nodejs/express/middleware"},{"title":"Express 常用中间件","tags":["Express"],"categories":["Notes","Server","Express"],"author":"毛先生","excerpt":"\nExpress 在不使用三方中间件的情况下，虽然可以使用 form 表单上传文件，但是无法将文件保存到静态文件资源目录中去，而我们可以使用 multer 来实现文件上传。\n\n## 发送数据（表单）\n","link":"/posts/notes/server/nodejs/express/multer"},{"title":"Koa 新一代 Web 开发框架","tags":["Express"],"categories":["Notes","Server","Express"],"author":"毛先生","excerpt":"\nKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。\n\n","link":"/posts/notes/server/nodejs/koa"},{"title":"Koa 常用中间件","tags":["Express"],"categories":["Notes","Server","Express"],"author":"毛先生","excerpt":"\nKoa 和 Express 一样是一个自身功能极简，完全是由路由和中间件构成的一个web开发框架，从本质上来说，一个 Koa 应用就是在调用各种中间件，而 Koa 也具有很多第三方中间件可以使用。\n\n","link":"/posts/notes/server/nodejs/koa/middleware"},{"title":"自定义 webpack loader","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\nwebpack作为前端项目的打包工具，具有很好的学习价值。Loader 可以帮助 webpack 将不同类型的文件转换为 webpack 可识别的模块。\n\n","link":"/posts/notes/client/module/webpack/advanced/loader"},{"title":"实现迷你 webpack","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\n其实 webpack 早期时候并不是用来当做一个脚手架来用的（loader，plugin 是后人慢慢加进去的功能），它只是一个把 es6 或者 commonJs 转换成浏览器可识别脚本的工具。而 mini webpack 就是对这一基本功能的实现。\n\n","link":"/posts/notes/client/module/webpack/advanced/mini-webpack"},{"title":"自定义 webpack plugin","tags":["webpack"],"categories":["Notes","Client","webpack"],"author":"毛先生","excerpt":"\nplugin(插件)是 webpack 的几大要素之一，plugin的目的在于在 webpack 构建打包生命周期中中执行一些可扩展性功能。它可以在 webpack 运行到某个时刻帮你做一些事情。plugin会在webpack初始化时,给相应的生命周期函数绑定监听事件，直至webpack执行到对应的那个生命周期函数,plugin绑定的事件就会触发。\n\n","link":"/posts/notes/client/module/webpack/advanced/plugin"}]
